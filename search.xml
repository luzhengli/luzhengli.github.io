<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pandas常用操作参考手册</title>
      <link href="/2020/07/27/Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html"/>
      <url>/2020/07/27/Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html</url>
      
        <content type="html"><![CDATA[<p>本文从数据操作的导向角度总结了Pandas的一些常见用法，提供场景的同时也提供了部分实例。主要是想给自己做一个参考，以便忘记后查询。</p><p>本文将会持续更新。</p><h1 id="series对象包含索引的数组"><a class="markdownIt-Anchor" href="#series对象包含索引的数组"></a> Series对象：包含索引的数组</h1><ul><li>Series是由索引和数组两部分构成的<ul><li>索引（这里的索引不仅限于数值型、还支持字符串）<ul><li>Pandas实现：<strong>RangeIndex对象（数值型）、Index（非数值型，如字符串）、DatetimeIndex（时间型）</strong></li><li><strong>访问索引</strong>：Series.index</li><li><strong>注：索引是有序的</strong></li></ul></li><li>数组<ul><li><strong>访问数组</strong>：Series.values</li></ul></li></ul></li><li><strong>常用属性</strong><ul><li>index：返回Series对象的索引</li><li>values：返回Series对象的数组对象</li><li>name：返回Series对象的名字<ul><li>可以使用Series.rename方法重命名</li></ul></li></ul></li><li><strong>常用操作及对应方法</strong><ul><li>创建Series<ul><li>实例化方法：pd.Series(data=None, index=None)</li><li>参数<ul><li>data（有多种格式）<ul><li>ndarray</li><li>字典：d={‘b’=1, ‘a’=0, ‘c’=2}<ul><li><strong>注</strong>：Python≥3.6，Pandas≥0.23时，索引将<strong>按dict的插入顺序排序</strong>。</li></ul></li><li>标量值：比如说一个数5<ul><li><strong>注</strong>：此时必须提供索引，否则确定数组部分长度。</li></ul></li></ul></li><li>index<ul><li>默认创建一个有序列表作为索引[0, 1, …, len(data)-1]，也可以传入字符串列表</li><li><strong>注</strong>：<ul><li>如果传入了索引，那么会按照索引的顺序排列数组数据。</li><li>索引值可以不唯一！如索引列表可以写成[‘a’,‘b’,‘c’,‘d’,‘d’]</li></ul></li></ul></li></ul></li></ul></li><li><strong>索引和切片</strong>（Series具备和ndarray类似的索引方式）<ul><li>索引<ul><li>利用索引的下标值：s[1]</li><li>利用索引名：s[‘a’]</li><li>花式索引：<ul><li>s[[‘b’,‘c’,‘a’]]</li><li>s[[2,1,3]]</li></ul></li><li>布尔索引：s[s&lt;2]</li><li>用loc和iloc进行类似numpy数组的’[ , ]'索引或切片（Dataframe部分有详细介绍）</li><li>带有重复标签的轴索引（pandas不强制索引唯一）：此时会根据索引是否重复返回Series或标量值</li></ul></li><li>切片<ul><li>利用索引的下标值：s[0:1]  # 不包含索引值为1的行</li><li>利用索引名：s[‘a’:‘b’]  # 包含索引名’b’的行</li><li>切片部分的值可以修改：s[‘a’,‘b’] = 5</li><li><strong>注</strong>：利用索引名进行分片，边界上行数据也是包含的！！而利用索引下标值进行分片，不包含右边界！！</li></ul></li></ul></li><li>获取Series对象的唯一值数组<ul><li>方法：Seires.unique()</li><li>返回值：array</li></ul></li><li>统计Series中各值出现的频次<ul><li>方法：Seires.value_counts()</li><li>返回值：Series。索引部分是可能出现的所有值，数组是各值出现的频次。</li></ul></li><li>获取Series中是否出现指定元素的一个bool型数组（之后可用于布尔索引或其他场景）<ul><li>方法：Seirse.isin(values)</li><li>参数<ul><li>values（可以是以下之一）<ul><li>数值序列</li><li>集合（元素为数值或字符串都可）</li><li>字符串序列</li></ul></li></ul></li><li>返回值：Seires。判断原Series元素是否出现在values中的一个bool型Series</li></ul></li><li><strong>统计一个列标签下各数值出现的频次</strong><ul><li>方法：Series.value_counts()</li></ul></li><li>重建索引，返回重建索引后的对象<ul><li>方法：Series.reindex(index=None, **kwargs)</li><li>参数<ul><li>index：array-like。指定的新索引的列表。如果新索引比数据行要长，则这些多余行数据会自动填充NaN</li><li>method：{None, ‘backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’}。表示填充方式。<ul><li>‘ffill’：以前一个值进行填充</li><li>None ：不填充（默认）</li><li>‘backfill’：以后一个值进行填充</li></ul></li><li>省略若干…</li></ul></li></ul></li></ul></li><li>类似numpy.array和dict的行为<ul><li>Seires具有类似numpy.array的行为<ul><li>类似的切片方式</li><li>都具有dtype属性</li><li><strong>Series转numpy.array</strong>：通过Series.to_numpy方法</li></ul></li><li>Series具有类似dict的行为<ul><li>都支持按键索引值和修改值</li><li>都支持通过in运算符判断某个行标签是否在Seireis索引中，如 ‘a’ in series</li><li>都支持通过 .get 方法获取值</li></ul></li></ul></li></ul><h1 id="dataframe对象"><a class="markdownIt-Anchor" href="#dataframe对象"></a> Dataframe对象</h1><ul><li>Dataframe包含<strong>index（行标签）</strong>、**columns（列标签）**以及数据三部分。</li><li>常用属性<ul><li><strong>values</strong>：返回Dataframe对象的数据（以array形式）</li><li>dtype<strong>s</strong>：返回每列数据的数据类型<ul><li><strong>注</strong>：区别于Series的属性dtype！</li></ul></li><li>T：返回Dataframe对象的转置</li></ul></li><li>常用操作及对应方法<ul><li><strong>创建Dataframe</strong><ul><li>实例化方法：pd.Dataframe(data=None, index=None, columns=None)</li><li>参数：<ul><li>data（有多种来源）<ul><li>Series为元素的字典：d = {‘one’: pd.Series([1., 2., 3.], index=[‘a’, ‘b’, ‘c’]), ‘two’: pd.Series([1., 2., 3., 4.], index=[‘a’, ‘b’, ‘c’, ‘d’])}<ul><li><strong>注</strong>：Dataframe可以看成是以列标签为键，Series为值的字典。</li></ul></li><li>list为元素的字典：d={“id”:[111,112,113],“name”:[“li”,“wang”,“hu”],“age”:[20,30,40]}<ul><li><strong>注</strong>：该方法的行索引需要另外使用index参数引入</li></ul></li><li>嵌套字典：d={‘age’: {‘li’: 20, ‘hu’: 40, ‘wang’: 90},‘sex’: {‘li’: ‘male’, ‘hu’: ‘female’, ‘wang’: ‘male’}}<ul><li><strong>注</strong>：列标签为外层字典的键，行标签为内层字典的键。</li></ul></li><li>字典列表：d：[{‘a’: 1, ‘b’: 2}, {‘a’: 5, ‘b’: 10, ‘c’: 20}]<ul><li><strong>注</strong>：<ul><li>列表中每一个元素(字典)都相当于DataFrame的一行数据</li><li>该方法的行索引需要另外使用index参数引入</li></ul></li></ul></li><li>外部文件<ul><li>csv格式（excel支持）<ul><li>导入方法：pd.read_csv</li></ul></li><li>xlsx格式（excel支持）<ul><li>导入方法：pandas.read_excel</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><strong>索引和切片</strong><ul><li>索引或切片列<ul><li><strong>索引单列</strong>（传入单个值，即列名）：s[‘one’]  # 选出名为’one’的列</li><li><strong>索引多列/花式索引</strong>：s[[‘two’,‘one’]]  # 按顺序选出名为’two’和’one’的两列，以Dataframe返回</li></ul></li><li>索引或切片行<ul><li>切片行：s[:2]  # 选出前两行数据，以Dataframe返回</li><li><strong>布尔索引</strong>：<ul><li><strong>过滤行</strong>：s[s[‘two’] &lt; 5]  # 选出名为’two’列数值小于5的所有行</li><li>**过滤行：**s[s.two &lt; 5]  # 选出名为’two’列数值小于5的所有行   # <strong>注</strong>：如果列名合法，可以按照属性的方式选取列</li><li>s[s&lt;5]   # 选出所有小于5的值，其余值置为NaN</li><li>s[s&lt;5]  = 0 # 选出所有小于5的值，并将其置零</li></ul></li></ul></li><li>用loc和iloc进行类似numpy数组的’[ , ]'索引或切片<ul><li><strong>用loc（轴标签）进行选取</strong><ul><li><strong>选取单一行或几行</strong>：data.loc[“Ohio”]</li><li>选取单一值：data.loc[“Utah”,“two”]</li><li>选取某几行数据的某几列（若行/列数有一个为1，则返回Series，否则返回Dataframe）：data.loc[[“Utah”,“New York”], [‘three’,‘four’]]</li></ul></li><li><strong>用loc进行切片</strong><ul><li>data.loc[:‘Utah’, ‘two’]</li><li>data.loc[‘Colorado’:‘Utah’, ‘two’:‘three’]</li></ul></li><li><strong>用iloc（整数索引）进行选取</strong><ul><li><strong>选取单一行或几行</strong>：data.iloc[1]</li><li>选取单一值：data.iloc[3,3]  # 选取4行4列上的元素</li><li>选取某几行数据的某几列（若行/列数有一个为1，则返回Series，否则返回Dataframe）：data.iloc[[2,3], [0, 1]]</li></ul></li><li><strong>用iloc进行切片</strong><ul><li>data.iloc[:2,:2]  # <strong>注</strong>：切片的右边界元素取不到</li><li>data.iloc[:, :3][data.three &gt; 5]  # 先切片，再布尔索引选取特定行</li></ul></li></ul></li><li>用at和iat选取单一值<ul><li>用at（传入行、列标签）选取单一值：<a href="http://data.at" target="_blank" rel="noopener">data.at</a>[‘Ohio’,‘two’]</li><li>用iat（传入行、列元素的整数索引值）选取单一值：data.iat[1,1]</li></ul></li><li>带有重复标签的轴索引（pandas不强制索引唯一）：此时会根据索引是否重复返回Dataframe或Seires</li><li><strong>注</strong>：<ul><li><strong>常见的错误索引方式</strong><ul><li>s[1]  # 传入单值时默认是索引列，必须要传入列名才行</li><li>s[-1]  # pandas不建议自后向前索引（有些情况会报错），这个Python的list不同，而应该使用loc或是iloc进行索引</li></ul></li></ul></li></ul></li><li><strong>排序</strong><ul><li>按轴标签排序<ul><li>方法：df.sort_index(axis=0,level=None,ascending=True,inplace=False,kind=‘quicksort’,na_position=‘last’,sort_remaining=True,by=None)</li><li>参数<ul><li>axis：0（默认，表示沿行标签名排序） or 1（沿列标签名排序）</li><li>ascending：True（默认） or False，表示是否按升序排列</li></ul></li></ul></li><li><strong>按值排序</strong><ul><li>方法：df.sort_values(<strong>by,axis=0</strong>,ascending=True,inplace=False,kind=‘quicksort’,na_position=‘last’)</li><li>参数<ul><li>by：行/列标签名或行/列标签名组成的列表。表示要<strong>按照列表中顺序依次排序</strong>行/列，即按某一行/列排序后，如果有相同值，再按列表中剩余的行/列排序<ul><li>排序行时要设置axis=0</li><li>排序列时要设置axis=1</li></ul></li></ul></li></ul></li></ul></li><li><strong>排名</strong><ul><li>方法：df.rank(axis=0,method=‘average’,numeric_only=None,na_option=‘keep’,ascending=True,pct=False)</li><li>使用方法可见juypter笔记或参考https://zhuanlan.zhihu.com/p/87593543</li></ul></li><li>生成时间型行索引<ul><li>函数：pd.date_range(start=None, end=None, period=None, freq=‘D’,…)</li><li>参数：<ul><li>start：str or datetime-like。起始时间</li><li>end：str or datetime-like。结束时间</li><li>periods ：integer。周期数</li><li>freq：str or DateOffset</li></ul></li></ul></li><li>数据量较大时查看前5行数据<ul><li>方法：df.head()</li></ul></li><li>返回Dataframe对象的详细信息<ul><li>方法：<a href="http://pd.info" target="_blank" rel="noopener">pd.info</a>()</li><li><strong>该函数返回的信息包括</strong>：行索引、列数、每列的信息（元素数、是否含null值、元素数据类型）、内存占用情况</li></ul></li><li>判断布尔型Dataframe对象中各列/行元素是否含有True<ul><li><strong>注</strong>：结合df.isnull()方法<strong>可以得知每列/行元素是否含有缺失值</strong><ul><li>eg1：df.isnull().any(0) # 判断各列是否含缺失值（sum中的0可以省略）</li><li>eg2：df.isnull().any(1) # 判断各行是否含缺失值</li></ul></li></ul></li><li>快速返回Dataframe<strong>每列</strong>数据的统计信息<ul><li>方法：df.describe()</li><li>这些统计信息包括：元素数、数学期望、标准差、最小/大值、分位数</li></ul></li><li>删除指定行索引/列索引的数据<ul><li>方法：df.drop(label=None,axis=0,index=None,columns=None,…)</li><li>参数<ul><li>label：list or list-like。行/列标签名</li><li>axis：0（默认） or 1。 0表示按行方向，1表示按列方向</li><li>index：list or list-like。行标签名</li><li>columns：list or list-like。列标签名</li></ul></li></ul></li><li><strong>缺失值处理</strong><ul><li>判断Dataframe对象的元素是否为null值，返回一个bool型Dateframe对象<ul><li>方法：df.isnull()</li><li><strong>注</strong>：结合sum()方法可以<strong>统计各列/行缺失数据的个数</strong><ul><li>eg1：df.isnull().sum(0) # 判断各列缺失数据的个数（sum中的0可以省略）</li><li>eg2：df.isnull().sum(1) # 判断各行缺失数据的个数</li></ul></li></ul></li><li>删除带有缺失值的行/列<ul><li>方法：df.dropna(axis=0,how=‘any’,thresh=None,subset=None,inplace=False)</li><li>参数<ul><li>axis：默认是0（删除行），可以设置为1（删除列）</li><li>how：默认是’any’（行/列中只要包含Null值就删除），可以改为’all’（必须整行/列是Null才删除）</li><li>thresh：non-Null数小于特定阈值thersh的行/列才删除（eg. 某列数据包含一个非Null值，设置thresh=1，则该列数据不会被删除）</li><li>subset：行标签或者列标签的列表（eg. [“names”, “age”, “bron”], [2,3,0]）。<ul><li>当为行标签的列表时、，表示删除列时要考虑是否存在Null值的行。</li><li>当为列标签的列表时，表示删除行时要考虑是否存在Null值的列。</li></ul></li><li>inplace：True或False（默认）。表示是否立即在本数据上生效。</li></ul></li></ul></li><li>填充缺失值<ul><li>方法：df.fillna(value=None,method=None,axis=None,inplace=False,limit=None,…)</li><li>参数<ul><li>value：scalar, dict, Series, or DataFrame。指定value中的值填充到df对应的行或列中。</li><li>method：‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None。method='ffill’表示以前面的值进行填充</li><li>axis：0 or ‘index’, 1 or ‘columns’。选择按列填充还是按行填充</li><li>inplace：是否立即修改</li><li>limit：限制填充的个数</li><li>实例：<a href="https://www.jb51.net/article/163899.htm" target="_blank" rel="noopener">https://www.jb51.net/article/163899.htm</a></li></ul></li></ul></li></ul></li><li>Dataframe转numpy.ndarray<ul><li>方法：df.to_numpy()</li></ul></li><li>重建索引，返回重建索引后的对象<ul><li>方法：df.reindex(labels=None,     index=None,     columns=None,     axis=None,     method=None,     copy=True,     level=None,     fill_value=nan,     limit=None,     tolerance=None )</li><li>参数<ul><li>labels：array-like。满足参数axis要求的要重建的行/列索引名</li><li>index/columns：array-like。要重建的行/列索引名</li><li>axis：int（0 or 1） or str（‘index’ or ‘columns’）。指定轴，用于表明labels是行索引还是列索引</li><li>method： {None, ‘backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’}。填充缺失值的方法，类似Series.reindex</li></ul></li><li><strong>注</strong>：<ul><li>一般要同时指定labels和axis参数（修改行索引时可省略axis）</li><li>labels/axis参数不与index/columns同时出现</li></ul></li></ul></li></ul></li><li>时间序列</li></ul><h1 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h1><h1 id="算数运算"><a class="markdownIt-Anchor" href="#算数运算"></a> 算数运算</h1><ul><li><p>常用运算符及对应函数</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/fc8a8217-ef8a-4db2-b6cd-50ce6fccab65-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li><li><p><strong>标签/数据对齐特性</strong>：通过对齐不同对象的行/列标签实现算数（加或减）运算（自动对标签相同的数据进行运算，标签没有匹配的取并集，且值取NaN）</p><ul><li><p>实例1：两Series相加</p><ul><li><p>s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=[‘a’, ‘c’, ‘d’, ‘e’])</p></li><li><p>s2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1], index=[‘a’, ‘c’, ‘e’, ‘f’, ‘g’])</p></li><li><p>s1 + s2</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/75f3b520-4c01-440a-85ff-45be084d0eee-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li><li><p>实例2：两Dataframe相加</p><ul><li><p>df1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list(‘bcd’), index=[‘Ohio’, ‘Texas’, ‘Colorado’])</p></li><li><p>df2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>df1+df2</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/756862cb-9d7f-48a9-a2e8-dadb73c49221-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li></ul></li><li><p><strong>广播特性</strong></p><ul><li><p>numpy中的广播：当一个二维数组减去它的第A行数据时，这个二维数组的每行数据会依次减去第A行数据。</p></li><li><p><strong>Pandas中的广播</strong>：</p><ul><li>当一个Dataframe减去它的第A行数据（即Series）时，这个二维数组的每行数据会依次减去第A行数据。</li><li>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集，缺失部分填充NaN值</li><li><strong>注</strong>：使用运算符时，是在行轴上广播。如果要在列轴上广播，要使用相应的运算函数。</li></ul></li><li><p>实例</p><ul><li><p>df = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>s = pd.Series(range(3), index=[‘b’, ‘e’, ‘f’])</p></li><li><p>df + s</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/980aeafb-7c70-4871-8382-8b75693e8cfc-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li></ul></li></ul><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><ul><li><p>应用内置函数</p></li><li><p><strong>函数映射</strong>（主要介绍Dataframe中的应用）：可以<strong>将某个函数应用到Dataframe的各行/列或个各个元素上，实现一些统计运算</strong></p><ul><li><p>作用于行/列</p><ul><li><p>方法：Series.apply或df.apply(<strong>func, axis=0</strong>,  raw=False, result_type=None,  args=(), **kwds, )</p></li><li><p>参数</p><ul><li>func：pandas内置函数或者自定义函数、lambda函数等。表示要应用到行或列上的函数。</li><li>axis：{0 or ‘index’, 1 or ‘columns’}, default 0。要应用到各列（axis=0）还是各行（axis=1）</li></ul></li><li><p>实例</p><ul><li><p><strong>计算Dataframe各列元素最大值与最小值之差，返回Series</strong></p><ul><li><p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>f = lambda x: x.max() - x.min()</p></li><li><p>frame.apply(func=f)</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/9aabd196-02f1-427e-b44c-ea989a92f429-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li><li><p><strong>计算Dataframe各行元素最小值和最大值，返回Dataframe</strong></p><ul><li><p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>f = lambda x: pd.Series([x.min(), x.max()], index=[‘min’,‘max’])</p></li><li><p>frame.apply(func=f, axis=1)</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/dc642aa8-3aef-4a93-bbdb-30869f081d8c-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li></ul></li></ul></li></ul></li><li><p>作用于各个元素（元素级）</p><ul><li><p>方法：Series.map或df.applymap(func) -&gt; ‘DataFrame’（主要介绍Dataframe）</p></li><li><p>实例</p><ul><li><p><strong>获取浮点值的格式化字符串</strong></p><ul><li><p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>frame.applymap(func=lambda x: ‘%.2f’ % x)</p><p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/550f5e62-8570-4e44-9894-4e4ecf934a53-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 参考手册 </category>
          
          <category> Pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Fluid主题的Hexo博客添加Utterance评论系统</title>
      <link href="/2020/07/20/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html"/>
      <url>/2020/07/20/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="github端"><a class="markdownIt-Anchor" href="#github端"></a> Github端</h1><p>创建GitHub仓库用于保存评论。</p><p>通过这个<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">链接</a>添加一个utterances app，</p><p>在配置页面选择你要用于保存评论的github仓库地址。</p><p>在utterances<a href="https://utteranc.es/" target="_blank" rel="noopener">官网</a>根据提示获取用于配置的代码（之后这部分代码将嵌入到文章模板页中）</p><h1 id="hexo端"><a class="markdownIt-Anchor" href="#hexo端"></a> Hexo端</h1><p>本来想用灵活嵌入的方式（只需在Fuid配置文件中配置相关项，无需手动嵌入到文章模板页），但是期间遇到一个bug始终无法解决，最后决定采取直接嵌入式的方法。</p><p>这里采用的是直接嵌入式的方法（将utterance评论区直接嵌入到文章模板页，这个文章模板页在我的电脑位于<code>themes\fluid\layout\post.ejs</code>）</p><p>找到评论区部分，先删去Fluid主题预置的代码，然后将前面获取到的配置代码嵌入进来，如下图所示</p><p><img src="%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720211718773.png" srcset="/img/loading.gif" alt="image-20200720211718773" /></p><p>在Fluid配置文件中让comment的配置项<code>enable: true</code>，即可开启评论。</p><p>此时重新生成静态文件然后部署网站即可看到评论。</p><p><img src="%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720211922988.png" srcset="/img/loading.gif" alt="image-20200720211922988" /></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utterances </tag>
            
            <tag> fluid </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为hexo博客的fluid主题添加gitalk评论系统</title>
      <link href="/2020/07/20/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html"/>
      <url>/2020/07/20/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<p>本文将详细介绍（图文）如何在hexo博客的fluid主题下添加gitalk系统。</p><p>gitalk是基于github issue的评论系统，详细的介绍可见<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md" target="_blank" rel="noopener">这里</a>。</p><h1 id="github端的准备"><a class="markdownIt-Anchor" href="#github端的准备"></a> github端的准备</h1><p>主要流程：</p><ol><li>注册GitHub账号</li><li>创建Github仓库，用于保存博客评论</li><li>添加OAuth App，为网站添加第三方（这里是GitHub）登录认证功能</li></ol><p>第1、2步都十分简单，不太清楚的朋友可以自行查阅资料。下面主要详细介绍添加OAuth App的过程：</p><p>首先点击个人头像，进入<code>Settings</code>选项卡</p><p><img src="%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720011753172.png" srcset="/img/loading.gif" alt="image-20200720011753172" /></p><p>选择<code>OAuth Apps</code>，点击<code>New OAuth App</code></p><p><img src="%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720012013813.png" srcset="/img/loading.gif" alt="image-20200720012013813" /></p><p>然后按照下方提示填写内容，新建一个OAuth App</p><p><img src="%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720012524757.png" srcset="/img/loading.gif" alt="image-20200720012524757" /></p><p>上述都完成后，可以在<code>OAuth Apps</code>选项卡看到你创建好的app</p><p><img src="%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720012629552.png" srcset="/img/loading.gif" alt="image-20200720012629552" /></p><p>点击进入app后记录下Client ID和Client Secret，这两个字符串在下一部分修改主题的配置文件时会使用到</p><p><img src="%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720013717628.png" srcset="/img/loading.gif" alt="image-20200720013717628" /></p><h1 id="hexo端的准备"><a class="markdownIt-Anchor" href="#hexo端的准备"></a> hexo端的准备</h1><p>对于fluid主题，只需要修改一下主题的配置文件<code>_config.yml</code>即可。</p><p>修改有关评论的所有项（注释部分介绍了含义）：</p><pre><code class="hljs yml"><span class="hljs-attr">comments:</span>  <span class="hljs-comment"># 评论</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启评论</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">gitalk</span>  <span class="hljs-comment"># 指定使用的评论模块，我们使用的是gitalk系统，所以填gitalk</span><span class="hljs-comment"># Gitalk</span><span class="hljs-comment"># You can get yout ClientID and ClientSecret from https://github.com/settings/applications/new</span><span class="hljs-comment"># More info available at https://github.com/gitalk/gitalk#options</span><span class="hljs-attr">gitalk:</span>  <span class="hljs-attr">clientID:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># GitHub Application Client ID，从OAuth APP中复制过来</span>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># GitHub Application Client Secret,从OAuth APP中复制过来</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">comments</span>  <span class="hljs-comment"># 你保存评论的仓库名（这里是我的仓库，请改成你自己的），请注意，它不是你的仓库完整路径，不包含你的GitHub用户名</span>  <span class="hljs-attr">owner:</span> <span class="hljs-string">'luzhengli'</span>  <span class="hljs-comment"># 你的GitHub用户名，注意外面用单引号包围起来！</span>  <span class="hljs-attr">admin:</span> <span class="hljs-string">['luzhengli']</span>  <span class="hljs-comment"># GitHub repo owner and collaborators, only these guys can initialize github issues, should be like "['admin']" or "['admin1','admin2']" 我这里设置成仅我个人能提交issue（即仅个人能初始化评论区）</span>  <span class="hljs-attr">id:</span> <span class="hljs-string">location.pathname</span>         <span class="hljs-comment"># The unique id of the page. Length must less than 50. 这个不用改</span>  <span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>               <span class="hljs-comment"># Localization language key, en, zh-CN and zh-TW are currently available. 中文网站也不用改</span>  <span class="hljs-attr">labels:</span> <span class="hljs-string">"['Gitalk']"</span>          <span class="hljs-comment"># GitHub issue labels. 一般不用改</span>  <span class="hljs-attr">perPage:</span> <span class="hljs-number">15</span>                   <span class="hljs-comment"># Pagination size, with maximum 100.</span>  <span class="hljs-attr">pagerDirection:</span> <span class="hljs-string">last</span>          <span class="hljs-comment"># Comment sorting direction, available values are last and first. 默认即可</span>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># Facebook-like distraction free mode. 默认即可</span>  <span class="hljs-attr">createIssueManually:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true. 默认即可</span></code></pre><p>最后，使用hexo的命令更新静态文件，然后重新部署网站，如果前面都没有问题，那么评论系统就已经搭建完毕了。</p><p>如果在<code>_config.yml</code>配置文件中设置了<code>admin</code>为自己，那么博客中每个文章页都需要你自己手动初始化评论区（对应于GitHub中提交一个issue），在这一点上，gitalk显得十分麻烦。不过不用担心，下一篇文章将介绍如何自动化初始化gitalk评论。</p><p><img src="%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/image-20200720014647865.png" srcset="/img/loading.gif" alt="image-20200720014647865" /></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> gitalk </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[视频]学会的第一支钢琴曲</title>
      <link href="/2020/05/03/%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%94%AF%E9%92%A2%E7%90%B4%E6%9B%B2.html"/>
      <url>/2020/05/03/%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%94%AF%E9%92%A2%E7%90%B4%E6%9B%B2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然看起来很简单，但刚上手的时候那真叫个手忙脚乱hh</p><p>ps：噪声感人/(ㄒoㄒ)/~~</p></blockquote><video width="720" height="480" controls><source src="学会的第一支钢琴曲\小星星.mp4"></video>]]></content>
      
      
      <categories>
          
          <category> 钢琴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一次 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言位运算的用途</title>
      <link href="/2020/04/27/C%E8%AF%AD%E8%A8%80%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%9D%E8%80%83.html"/>
      <url>/2020/04/27/C%E8%AF%AD%E8%A8%80%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%9D%E8%80%83.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近复习C语言学到位运算，发现这个特性很灵活，绝不仅仅是简单的与或非语法而已，为加深印象还是决定记录下。位运算的不同运算符结合场景是具有一定含义的，本文分别介绍了按位与或非的基本语法，以及各自的使用场景。</p></blockquote><h1 id="按位与"><a class="markdownIt-Anchor" href="#按位与"></a> 按位与(&amp;)</h1><p>语法简记：有0得0，全1得1</p><p>使用场景：</p><ul><li>“屏蔽”信息位，具体来说包含两层：<ul><li>取特定位：当一个二进制位与0进行“与”时，就可以将其置0，从而屏蔽该信息。</li><li>取特定位：当一个二进制位与1进行“与”时，就可以“取”出该数。</li></ul></li></ul><p>综合两部分，可以用按位与运算符取出一个二进制串的特定位信息，并屏蔽特定位信息。<strong>屏蔽信息位值得单独强调，它有时可以实现掩饰（mask）的效果，比如<code>10011011 &amp; 00000111 = 00000011</code>，这有可能强调之后要操作二进制序列的最后三位（即保留这三位的信息），因此实现通过<code>&amp;</code>将前5位掩饰（mask）起来</strong>。</p><h1 id="或"><a class="markdownIt-Anchor" href="#或"></a> 或(|)</h1><p>语法简记：有1得1，全0得0</p><p>使用场景：</p><ul><li>置位：当一个二进制位与1进行“与”时，就可以将其置1。置位操作和常见，以前写C51时也常用，为I/O提供一个初始电平。</li></ul><h1 id="按位非~"><a class="markdownIt-Anchor" href="#按位非~"></a> 按位非(~)</h1><blockquote><p>这个比较特殊，按位非是一个单目运算，也因此很简单。</p></blockquote><p>语法简记：有1得0，有0得1</p><p>使用场景：</p><ul><li>一时只想到切换单片机的I/O口电气状态了，比如控制流水灯的亮灭等。</li></ul><h1 id="按位异或"><a class="markdownIt-Anchor" href="#按位异或"></a> 按位异或(^)</h1><blockquote><p>这个运算符很强大，以前总觉得异或很奇怪，后来才知道大有用处。</p></blockquote><p>语法简记：相同为1，不同为0</p><p>语法的理解：判断两个位是否为“异”，如果是，则取<code>1</code>，否则取<code>0</code>。即不同为<code>1</code>，相同为<code>0</code>。</p><p><strong>异或运算的性质</strong>：</p><ul><li>异或满足交换律和结合律</li><li>x ^ x == 0</li><li>x ^ 0 == x</li><li>x ^ 1 == ~x</li></ul><p>异或运算的性质带来的更多有趣的应用场景：</p><ul><li><p>所有位置零：与自身异或</p></li><li><p>使特定位翻转（相当于实现了<code>~</code>的功能，但比<code>~</code>更灵活）：与1异或</p></li><li><p>使特定位保留原值：与0异或</p></li><li><p>交换两个值，不用临时变量：</p>  <pre><code class="hljs c">a = a^b;b = a^b;a = a^b;</code></pre><ul><li>优点：不用临时变量</li><li>缺点：速度没有使用临时变量快、当a、b引用的是一个同一个对象时，会使该变量为0。</li></ul></li></ul><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p>[1] 《C语言程序设计（第四版）谭浩强著》</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[视频]抓住人生的高尔夫球</title>
      <link href="/2020/04/20/%E8%A7%86%E9%A2%91-%E6%8A%93%E4%BD%8F%E4%BA%BA%E7%94%9F%E7%9A%84%E9%AB%98%E5%B0%94%E5%A4%AB%E7%90%83.html"/>
      <url>/2020/04/20/%E8%A7%86%E9%A2%91-%E6%8A%93%E4%BD%8F%E4%BA%BA%E7%94%9F%E7%9A%84%E9%AB%98%E5%B0%94%E5%A4%AB%E7%90%83.html</url>
      
        <content type="html"><![CDATA[<p>值得反复观看和思考：</p><video width="720" height="480" controls><source src="视频-抓住人生的高尔夫球\《时间管理》.mp4"></video>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
            <tag> 时间管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo新建、编辑并预览文章</title>
      <link href="/2020/04/16/%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0.html"/>
      <url>/2020/04/16/%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0.html</url>
      
        <content type="html"><![CDATA[<p>阅读本文之前，你应当已经搭建并部署好了hexo博客，如果没有我推荐一个实战视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><p>本文将介绍如何在hexo博客中创建、编辑、预览文章，以及如何自定义主题。最后还记录了一些个人部署博客时遇到的坑。</p><h1 id="新建文章"><a class="markdownIt-Anchor" href="#新建文章"></a> 新建文章</h1><h2 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h2><blockquote><p>命令：<code>hexo new [layout] title</code>或 <code>hexo n [layout] title</code></p></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><pre><code class="hljs bash">$ hexo n text1</code></pre><p>当然你还可以指定布局：</p><pre><code class="hljs bash">$ hexo n [layout_name] draft1</code></pre><p>该命令创建了一个使用特定布局的名为draft1的文章。</p><p>打开之前创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><pre><code class="hljs yml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">text1</span><span class="hljs-attr">author:</span> <span class="hljs-string">luyao</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-10</span> <span class="hljs-number">04</span><span class="hljs-string">:13:36</span><span class="hljs-attr">tags:</span> <span class="hljs-string">hexo</span><span class="hljs-attr">categories:</span> <span class="hljs-string">blog</span><span class="hljs-meta">---</span></code></pre><p>你显示的内容可能未必与我一样，不必担心，这是由于我自定义过。只需要知道，上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。比如使<code>author: luyao</code>，那么渲染后的文章中将显示文章作者为<code>luyao</code>。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件：<img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416160635509.png" srcset="/img/loading.gif" alt="image-20200416160635509" /></p><p>而每一个文件中的内容实际只包含一个Front-matter。<img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416160817070.png" srcset="/img/loading.gif" alt="image-20200416160817070" />因此，你可以在这里修改布局或者建立新的布局，然后创建文章时使用这些布局。</p><h2 id="草稿"><a class="markdownIt-Anchor" href="#草稿"></a> 草稿</h2><p>使用<code>hexo n draft draft1</code>命令将在<code>source\</code>目录下创建<code>_drafts</code>目录，并生成一个<code>draft1.md</code>文件。</p><p>当你编辑完草稿后，可以把文章推送到<code>_posts</code>目录下，通过下面的命令：</p><pre><code class="hljs bash">$ hexo publish &lt;file_name&gt;</code></pre><p>可以使用<code>hexo --draft</code>命令可以查看已有草稿。</p><p>想要在本地预览草稿的静态文件，也需要在生成静态文件时加上<code>draft</code>参数。</p><h1 id="编辑文章"><a class="markdownIt-Anchor" href="#编辑文章"></a> 编辑文章</h1><p>以下将介绍一些markdown语法。由于markdown在不同平台的实现略有不用，因此下面的内容只会介绍hexo默认支持的语法（特别基础的常用语法将不再说明，例如<code>#</code>）。此外，由于主题不同，不同机器显示效果也有会一定差异。</p><p>以下是本人操作的环境：</p><ul><li>编辑器：typora</li><li>hexo主题：cactus</li></ul><h2 id="插入图片"><a class="markdownIt-Anchor" href="#插入图片"></a> 插入图片</h2><p>图片几乎是我们写博客时不可或缺的元素。在hexo中插入图片需要先进行一些设置，不过在介绍那之前让我们先回顾一下markdown引用图片的语法：</p><pre><code class="hljs markdown">![<span class="hljs-string">alt</span>](<span class="hljs-link">path [title]</span>)</code></pre><ul><li>path是必选的，表示图片的路径，可使用绝对或相对路径。</li><li>alt是可选的，是图片无法加载时的替代描述文本。</li><li>title是可选的，是图片的标题。</li></ul><p>在hexo中，引用图片不是简单的使用上述语法即可，你还需要为图片制定一个<strong>资源文件夹</strong>。具体来说，hexo中文章引用图片有两种方式：</p><ol><li><p>将所有文章的图片放到<code>source/images</code> 文件夹中（没有就自己创建一个），然后使用markdown语句引用图片。这种方法一般适用于包含少量图片的hexo项目，但是当文章数量增多，图片数也随之增加后，该管理方式就显得有些混乱。因此我个人推荐你使用下面一种方法。</p></li><li><p>为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：</p><ol><li><p>在博客根目录打开<code>_config.yml</code>文件做如下修改：</p> <pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span></code></pre></li><li><p>然后使用<code>hexo n text</code>命令后创建一个使用post布局名为text的文章，你将发现hexo在<code>\source\_post</code>文件夹下创建了一个<code>\text</code>文件夹以及同名的<code>.md</code>文件：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200418002619163.png" srcset="/img/loading.gif" alt="image-20200418002619163" /></p></li><li><p>最后就可以打开<code>text.md</code>文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。<strong>注意</strong>：请不要自作聪明将<code>text.md</code>文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用（如果有兴趣可以试试，成功了记得下@博主）。</p></li></ol></li></ol><p><strong>Tip</strong>：如果你使用的是<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>编辑器，可以在编辑器的文件/偏好设置/图像中进行如下设置：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200418003255735.png" srcset="/img/loading.gif" alt="image-20200418003255735" /></p><p>这样你每次直接拷贝到文章的截图将会被自动保存到同名的文件夹下，非常方便~</p><h2 id="插入视频"><a class="markdownIt-Anchor" href="#插入视频"></a> 插入视频</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"480"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"320"</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">video_path</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span></code></pre><ul><li>video_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。</li><li>width和height是视频区块的宽度和高度，可自定义。</li></ul><h2 id="引用区块"><a class="markdownIt-Anchor" href="#引用区块"></a> 引用区块</h2><pre><code class="hljs markdown">&#123;% blockquote [author[, source]] [link] [source<span class="hljs-emphasis">_link_</span>title] %&#125;content...&#123;% endblockquote %&#125;</code></pre><p>例如：</p><pre><code class="hljs markdown">&#123;% blockquote luzhengli hello-world https://luzhengli.github.io/2020/04/10/hello-world/ %&#125;Quick Start&#123;% endblockquote %&#125;</code></pre><p>效果如下：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416171525436.png" srcset="/img/loading.gif" alt="image-20200416171525436" /></p><p>还有一种简单的引用语法：</p><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 这也是引用</span>&gt;<span class="hljs-quote">&gt; 引用1</span>&gt;<span class="hljs-quote">&gt; 饮用2</span></code></pre><p>效果如下：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416171816955.png" srcset="/img/loading.gif" alt="image-20200416171816955" /></p><h2 id="代码区块"><a class="markdownIt-Anchor" href="#代码区块"></a> 代码区块</h2><pre><code class="hljs markdown">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;code snippet&#123;% endcodeblock %&#125;</code></pre><p>上述形式写起来比较麻烦，我比较喜欢用另外一种语法：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416175337363.png" srcset="/img/loading.gif" alt="image-20200416175337363" /></p><p>例如：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416175146292.png" srcset="/img/loading.gif" alt="image-20200416175146292" /></p><p>效果如下：<br /><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416171403074.png" srcset="/img/loading.gif" alt="image-20200416171403074" /></p><p>hexo还提供了一些<a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">标签插件</a>支持你引用其他资源，如视频、iframe等。不过不常用，有兴趣的朋友可以自己了解下。</p><h1 id="本地预览"><a class="markdownIt-Anchor" href="#本地预览"></a> 本地预览</h1><p>编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。</p><h2 id="生成删除静态文件"><a class="markdownIt-Anchor" href="#生成删除静态文件"></a> 生成/删除静态文件</h2><blockquote><p>生成静态文件命令：<code>hexo generate</code>或 <code>hexo g</code></p><p>删除静态文件命令：<code>hexo clean</code></p></blockquote><p>正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。</p><p>如果发生了一些错误，可以先删除静态文件，然后再重新生成。<code>hexo g</code>命令还提供了一个参数<code>-f</code>提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。</p><h2 id="启动本地端口"><a class="markdownIt-Anchor" href="#启动本地端口"></a> 启动本地端口</h2><blockquote><p>命令：<code>hexo server</code>或 <code>hexo s</code></p></blockquote><p>生成静态文件之后，便要启动本地端口。然后访问命令行返回的地址便能在本地访问到博客了。</p><p>效果如下：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200418010323851.png" srcset="/img/loading.gif" alt="image-20200418010323851" /></p><h1 id="自定义主题"><a class="markdownIt-Anchor" href="#自定义主题"></a> 自定义主题</h1><p>启用主题的步骤：</p><ul><li>在GitHub上克隆你喜欢的hexo主题到本地博客的根目录的theme文件夹下：<code>git clone &lt;url&gt; themes/&lt;theme_name&gt;</code></li><li>修改<code>_config.yml</code>文件的theme字段为下载好的主题名，例如：<code>theme: yilia</code></li><li>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</li><li>重新生成静态文件：<code>hexo g</code></li><li>启动本地端口查看效果：<code>hexo s</code></li><li>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</li></ul><p>以上只是主题的启用方法，每个主题还支持许多个性化操作，这些内容需要详见主题的文档。</p><h1 id="再次部署"><a class="markdownIt-Anchor" href="#再次部署"></a> 再次部署</h1><blockquote><p>命令：<code>hexo deploy</code>或 <code>hexo d</code></p></blockquote><p>部署之后等待一会就能通过公网访问到博客了。</p><h1 id="踩过的坑"><a class="markdownIt-Anchor" href="#踩过的坑"></a> 踩过的坑</h1><ol><li><p>部署到github时，仓库名称没有和github账户名一致（这里需要特别小心，账户名≠name）。举例来说，在github个人主页中，小字部分<code>luzhengli</code>才是账户名：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416163415605.png" srcset="/img/loading.gif" alt="image-20200416163415605" /></p></li><li><p>部署后发现无法通过主域名访问，必须主域名+index.html才能访问。解决办法如下：</p><ul><li><p>先查看github主目录是否有index.html</p></li><li><p>删掉.deploy_git文件夹</p></li><li><p>依次输入命令：<code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>。</p></li></ul></li></ol><p>最后的大杀器：当遇到无法解决的问题时，可以直接把blog所在的博客目录删除！重新走一遍流程。</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p>[0] <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a></p><p>[1] <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a></p><p>[2] <a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/writing</a></p><p>[3] <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/front-matter</a></p><p>[4] <a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins</a></p><p>[5] <a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
