<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用hexo新建、编辑并预览文章</title>
      <link href="/2020/04/16/%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0.html"/>
      <url>/2020/04/16/%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0.html</url>
      
        <content type="html"><![CDATA[<p>阅读本文之前，你应当已经搭建并部署好了hexo博客，如果没有我推荐一个实战视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><p>本文将介绍如何在hexo博客中创建、编辑、预览文章，以及如何自定义主题。最后还记录了一些个人部署博客时遇到的坑。</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><blockquote><p>命令：<code>hexo new [layout] title</code>或 <code>hexo n [layout] title</code></p></blockquote><p>hexo支持三种布局（layout）：post(默认)、draft、page。布局可以理解成文章的模板。我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n text1</span><br></pre></td></tr></table></figure><p>当然你还可以指定布局：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n [layout_name] draft1</span><br></pre></td></tr></table></figure><p>该命令创建了一个使用特定布局的名为draft1的文章。</p><p>打开之前创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">text1</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">luyao</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-04</span><span class="number">-10</span> <span class="number">04</span><span class="string">:13:36</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">blog</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>你显示的内容可能未必与我一样，不必担心，这是由于我自定义过。只需要知道，上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。比如使<code>author: luyao</code>，那么渲染后的文章中将显示文章作者为<code>luyao</code>。</p><p>如何自定义布局呢？实际上，布局实际是一个markdown文件，它们保存在<code>scaffolds/</code>目录下。<img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416160635509.png" alt="image-20200416160635509"></p><p>而每一个文件中的内容实际只包含一个Front-matter。<img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416160817070.png" alt="image-20200416160817070">因此，你可以在这里修改布局或者建立新的布局，然后创建文章时使用这些布局。</p><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>使用<code>hexo n draft draft1</code>命令将在<code>source\</code>目录下创建<code>_drafts</code>目录，并生成一个<code>draft1.md</code>文件。</p><p>当你编辑完草稿后，可以把文章推送到<code>_posts</code>目录下，通过下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>可以使用<code>hexo --draft</code>命令可以查看已有草稿。</p><p>想要在本地预览草稿的静态文件，也需要在生成静态文件时加上<code>draft</code>参数。</p><h1 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h1><p>以下将介绍一些markdown语法。由于markdown在不同平台的实现略有不用，因此下面的内容只会介绍hexo默认支持的语法（特别基础的常用语法将不再说明，例如<code>#</code>）。此外，由于主题不同，显示效果也有会一定差异。</p><p>以下操作的环境：</p><ul><li>编辑器：typora</li><li>hexo主题：cactus</li></ul><h2 id="引用区块"><a href="#引用区块" class="headerlink" title="引用区块"></a>引用区块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source<span class="emphasis">_link_</span>title] %&#125;</span><br><span class="line">content...</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote luzhengli hello-world https://luzhengli.github.io/2020/04/10/hello-world/ %&#125;</span><br><span class="line">Quick Start</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416171525436.png" alt="image-20200416171525436"></p><p>还有一种简单的引用语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这也是引用</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; 引用1</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; 饮用2</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416171816955.png" alt="image-20200416171816955"></p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>上述形式写起来比较麻烦，我比较喜欢用另外一种语法：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416175337363.png" alt="image-20200416175337363"></p><p>例如：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416175146292.png" alt="image-20200416175146292"></p><p>效果如下：<br><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416171403074.png" alt="image-20200416171403074"></p><h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><h2 id="生成-删除静态文件"><a href="#生成-删除静态文件" class="headerlink" title="生成/删除静态文件"></a>生成/删除静态文件</h2><blockquote><p>生成静态文件命令：<code>hexo generate</code>或 <code>hexo g</code></p><p>删除静态文件命令：<code>hexo clean</code></p></blockquote><p>在本地编辑好markdown文件后，便要生成静态文件。</p><h2 id="启动本地端口"><a href="#启动本地端口" class="headerlink" title="启动本地端口"></a>启动本地端口</h2><blockquote><p>命令：<code>hexo server</code>或 <code>hexo s</code></p></blockquote><p>生成静态文件之后，便要启动本地端口。接着便能在本地访问到博客。</p><h1 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h1><p>启用主题的步骤：</p><ul><li>在GitHub上克隆你喜欢的hexo主题到本地博客的根目录的theme文件夹下：<code>git clone &lt;url&gt; themes/&lt;theme_name&gt;</code></li><li>修改<code>_config.yml</code>文件的theme字段为下载好的主题名，例如：<code>theme: yilia</code></li><li>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</li><li>重新生成静态文件：<code>hexo g</code></li><li>启动本地端口查看效果：<code>hexo s</code></li><li>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</li></ul><p>以上只是主题的启用方法，每个主题还支持许多个性化操作，这些内容需要详见主题的文档。</p><h1 id="再次部署"><a href="#再次部署" class="headerlink" title="再次部署"></a>再次部署</h1><blockquote><p>命令：<code>hexo deploy</code>或 <code>hexo d</code></p></blockquote><p>部署之后就能通过公网访问到博客了。</p><h1 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h1><ol><li><p>部署到github时，仓库名称没有和github账户名一致（这里需要特别小心，账户名≠name）。举例来说，在github个人主页中，小字部分<code>luzhengli</code>才是账户名：</p><p> <img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416163415605.png" alt="image-20200416163415605"></p></li><li><p>部署后发现无法通过主域名访问，必须主域名+index.html才能访问。解决办法如下：</p><ul><li><p>先查看github主目录是否有index.html</p></li><li><p>删掉.deploy_git文件夹</p></li><li><p>依次输入命令：<code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>。</p></li></ul></li></ol><p>最后的大杀器：当遇到无法解决的问题时，可以直接把blog所在的博客目录删除！重新走一遍流程。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C笔记</title>
      <link href="/2020/04/16/C%E7%AC%94%E8%AE%B0.html"/>
      <url>/2020/04/16/C%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个计算机背景知识"><a href="#一个计算机背景知识" class="headerlink" title="一个计算机背景知识"></a>一个计算机背景知识</h1><h2 id="计算机中数字以二进制补码形式存储"><a href="#计算机中数字以二进制补码形式存储" class="headerlink" title="计算机中数字以二进制补码形式存储"></a>计算机中数字以二进制补码形式存储</h2><p>原码、反码、补码是什么？为什么要用？以及数学背景：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html#!comments" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html#!comments</a></p><p><strong>注：-128的补码是<code>10000000</code>，且没有原码和反码！计算机中一个八位有符号数的范围是：-128~127</strong></p><h1 id="C程序的运行步骤"><a href="#C程序的运行步骤" class="headerlink" title="C程序的运行步骤"></a>C程序的运行步骤</h1><p><img src="file://D:/Li/PicturesForTypora/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg?lastModify=1586982887" alt="img"></p><h1 id="算法以及表示"><a href="#算法以及表示" class="headerlink" title="算法以及表示"></a>算法以及表示</h1><h2 id="用传统流程图、N-S流程图（盒图）表示-算法"><a href="#用传统流程图、N-S流程图（盒图）表示-算法" class="headerlink" title="用传统流程图、N-S流程图（盒图）表示 算法"></a>用传统流程图、N-S流程图（盒图）表示 算法</h2><p>结构化算法：由三种基本结构组成的算法（顺序、选择、循环[当型&amp;直到型]）。</p><p>N-S流程图只能描述的是结构化算法，非结构化算法可以在保证功能不变的情况下转为结构化算法。</p><h2 id="用伪代码-设计-算法"><a href="#用伪代码-设计-算法" class="headerlink" title="用伪代码 设计 算法"></a>用伪代码 设计 算法</h2><h2 id="用计算机语言-实现-算法"><a href="#用计算机语言-实现-算法" class="headerlink" title="用计算机语言 实现 算法"></a>用计算机语言 实现 算法</h2><h2 id="结构化程序的设计"><a href="#结构化程序的设计" class="headerlink" title="结构化程序的设计"></a>结构化程序的设计</h2><ul><li>结构化程序<ul><li>模块1<ul><li>基本结构1</li><li>基本结构n</li></ul></li><li>模块n</li></ul></li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="file://D:/Li/PicturesForTypora/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E6%98%9F%E5%8F%B7%E8%A1%A8%E7%A4%BAC99%E6%94%AF%E6%8C%81).jpg?lastModify=1586982887" alt="img"></p><p>C语言的数据类型含义：规定数据的<strong>存储单元长度</strong>（字节数）和<strong>存储形式</strong>。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型在不同编译系统的下存储单元的长度不同，有的是2B，有的是4B。</p><blockquote><p>C标准没有规定某种数据类型的具体所占存储单元长度，这由编译系统自行决定。C标准只规定了 <code>sizeof(short int) ≤ sizeof(int) ≤ sizeof(long int) ≤ sizeof(long long int)</code>。将代码进行迁移时需要特别注意不同系统规定的数据类型所占存储单元长度。</p></blockquote><p>整型在计算机中以<strong>二进制补码形式</strong>存储(最高位是符号位)，存在一个范围。当超出该范围时，会发生<strong>溢出</strong>。</p><p>根据需要，在类型名前加上<strong>修饰符`unsigned</strong>`可表示一个无符号数。</p><blockquote><ol><li>只有整型数据可以加修饰符<code>unsigned</code>，实型数据不行。</li><li>通过<strong><code>%u</code></strong>输出十进制的无符号数据。</li></ol></blockquote><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>字符型也属于一种整型，可以理解成用一个字节表示的整型。</p><p>字符型可分别有符号和无符号的。</p><p><img src="file://D:/Li/PicturesForTypora/%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4.jpg?lastModify=1586982887" alt="img"></p><ul><li><p>与整型数据不同，在未指定修饰符<code>signed</code>或<code>unsigned</code>时，字符型数据按有无符号处理是由编译系统自己规定的。可以通过下面的代码进行测试：</p><p>  1</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c &#x3D; 255;</span><br></pre></td></tr></table></figure><p>  2</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d&quot;, c);  &#x2F;&#x2F; 若打印结果是-1 则说明编译系统默认字符数据是有符号的</span><br></pre></td></tr></table></figure></li><li><p>当编译系统默认c是有符号字符类型时，将产生<strong>溢出现象</strong>。具体解释如下：</p><p>  /* 上述代码现象的解释 */   假设编译系统默认字符是有符号的。 char c = 255; 这一步发生了两件事： 1)255以signed int类型保存(4字节的二进制补码形式，在这一标准下的机器码是<code>[00000000 00000000 00000000 11111111]补</code>，真值是+128) 2)赋值时，计算机以signed char类型保存变量，只取1)中的最低一个字节的二进制数。此时变量c在内存中的机器数是<code>[11111111]补</code>，真值是-1。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/04/16/test.html"/>
      <url>/2020/04/16/test.html</url>
      
        <content type="html"><![CDATA[<h1 id="引用区块"><a href="#引用区块" class="headerlink" title="引用区块"></a>引用区块</h1><blockquote><p>Quick Start</p><footer><strong>luzhengli hello-world</strong><cite><a href="https://luzhengli.github.io/2020/04/10/hello-world/" target="_blank" rel="noopener">luzhengli.github.io/2020/04/10/hello-world</a></cite></footer></blockquote><p>另外一种引用方法：</p><blockquote><p>这也是引用</p><p>引用1</p><p>饮用2</p></blockquote><h1 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h1><figure class="highlight python"><figcaption><span>file.py</span><a href="https://luzhengli.github.io/2020/04/10/hello-world/" target="_blank" rel="noopener">hello-world</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;[language] [title] [url] [link text]</span><br><span class="line">code snippet</span><br><span class="line">​</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
          <category> PlayStation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS3 </tag>
            
            <tag> Games </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
