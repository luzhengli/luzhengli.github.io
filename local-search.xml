<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>吉他弹唱练习：兰花草</title>
    <link href="/2020/08/08/%E5%90%89%E4%BB%96%E5%BC%B9%E5%94%B1%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%85%B0%E8%8A%B1%E8%8D%89.html"/>
    <url>/2020/08/08/%E5%90%89%E4%BB%96%E5%BC%B9%E5%94%B1%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%85%B0%E8%8A%B1%E8%8D%89.html</url>
    
    <content type="html"><![CDATA[<p>练习内容</p><ul><li>和弦：Am、Em</li><li>和弦衔接：Am&lt;-&gt;Em</li><li>右手手型：53231323</li><li>节奏感</li></ul><h1 id="乐谱"><a class="markdownIt-Anchor" href="#乐谱"></a> 乐谱</h1><p><img src="https://gitee.com/llillz/images/raw/master/%E4%B9%90%E8%B0%B1%EF%BC%9A%E5%85%B0%E8%8A%B1%E8%8D%89.jpg" srcset="/img/loading.gif" alt="" /></p><h1 id="视频"><a class="markdownIt-Anchor" href="#视频"></a> 视频</h1><ul><li>速度：75</li><li>变调夹：3品</li></ul><video width=100% height=100% controls><source src="吉他弹唱练习：兰花草\兰花草.mp4"></video><p>os：录的时候想起这是第一个vlog就紧张起来了，导致最后一句咬字不清 -_-||</p>]]></content>
    
    
    <categories>
      
      <category>吉他</category>
      
      <category>弹唱</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吉他</tag>
      
      <tag>弹唱练习</tag>
      
      <tag>视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas使用技巧：对大文件进行分块操作</title>
    <link href="/2020/08/02/Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C.html"/>
    <url>/2020/08/02/Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C.html</url>
    
    <content type="html"><![CDATA[<p>真实世界中我们通常要处理数据量很大的文件（千万级、亿级）。如果直接使用pandas的IO函数读取这类文件，机器的内存一般吃不消。</p><p><strong>为了高效处理大文件，pandas的IO函数提供了分块读取的功能（通过chunksize参数实现）</strong>。我们看一个例子。</p><h1 id="引例"><a class="markdownIt-Anchor" href="#引例"></a> 引例</h1><p>'ex6.csv’是包含10000行数据的文件（<a href="https://github.com/wesm/pydata-book/blob/2nd-edition/examples/ex6.csv" target="_blank" rel="noopener">下载</a>），其结构如下：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802142212061-1596364094943.png" srcset="/img/loading.gif" alt="image-20200802142212061" /></p><p>假设现在希望统计’key’列所有值的频次。如果能一次读取该文件，可以直接使用<code>Series.value_counts</code>方法解决：</p><pre><code class="hljs python">df = read_csv(<span class="hljs-string">'ex6.csv'</span>)df.value_counts()</code></pre><p>上述方法对于本例的数据量来说还可行，但如果文件过大，我们一般会先分块读取，再进行操作。对于本例来说就是先将文件读取为一个个块（chunk），再统计各个块的值的频次，然后将所有统计结果（Series对象）相加：</p><pre><code class="hljs python">chunker = read_csv(<span class="hljs-string">'ex6.csv'</span>, chunksize=<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 分块读取，每个块包含1000行数据</span>tot = pd.Series()  <span class="hljs-comment"># 创建空Series 用于保存中间计算结果</span><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunker:    tot = tot.add(chunk[<span class="hljs-string">'key'</span>].value_counts(), fill_value=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 各chunk数值统计结果再求和</span>tot = tot.sort_values(ascending=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 降序排列</span></code></pre><ul><li><code>chunk['key'].value_counts()</code>会获得每个块的数值频次的统计结果（返回Seires对象）</li><li><code>Series.add</code>方法可以实现两个Series的加法，还可以设置fill_value参数以填充空缺值。</li></ul><p>还会陆续补充其他案例…</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pandas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas常用操作参考手册</title>
    <link href="/2020/07/27/Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html"/>
    <url>/2020/07/27/Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html</url>
    
    <content type="html"><![CDATA[<p>本文从数据操作的导向角度总结了Pandas的一些常见用法，提供场景的同时也提供了部分实例。主要是想给自己做一个参考，以便忘记后查询。</p><p>本文将会持续更新。</p><h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1><h2 id="series对象包含索引的数组"><a class="markdownIt-Anchor" href="#series对象包含索引的数组"></a> Series对象：包含索引的数组</h2><p>Series是由索引和数组两部分构成的</p><ul><li>索引（这里的索引不仅限于数值型、还支持字符串）<ul><li>Pandas实现：<strong>RangeIndex对象（数值型）、Index（非数值型，如字符串）、DatetimeIndex（时间型）</strong></li><li><strong>访问索引</strong>：Series.index</li><li><strong>注：索引是有序的</strong></li></ul></li><li>数组<ul><li><strong>访问数组</strong>：Series.values</li></ul></li></ul><h3 id="常用属性"><a class="markdownIt-Anchor" href="#常用属性"></a> <strong>常用属性</strong></h3><ul><li>index：返回Series对象的索引</li><li>values：返回Series对象的数组对象</li><li>name：返回Series对象的名字<ul><li>可以使用Series.rename方法重命名</li></ul></li></ul><h3 id="常用操作及对应方法"><a class="markdownIt-Anchor" href="#常用操作及对应方法"></a> <strong>常用操作及对应方法</strong></h3><ul><li><p>创建Series</p><ul><li>实例化方法：pd.Series(data=None, index=None)</li><li>参数<ul><li>data（有多种格式）<ul><li>ndarray</li><li>字典：d={‘b’=1, ‘a’=0, ‘c’=2}<ul><li><strong>注</strong>：Python≥3.6，Pandas≥0.23时，索引将<strong>按dict的插入顺序排序</strong>。</li></ul></li><li>标量值：比如说一个数5<ul><li><strong>注</strong>：此时必须提供索引，否则确定数组部分长度。</li></ul></li></ul></li><li>index<ul><li>默认创建一个有序列表作为索引[0, 1, …, len(data)-1]，也可以传入字符串列表</li><li><strong>注</strong>：<ul><li>如果传入了索引，那么会按照索引的顺序排列数组数据。</li><li>索引值可以不唯一！如索引列表可以写成[‘a’,‘b’,‘c’,‘d’,‘d’]</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>索引和切片</strong>（Series具备和ndarray类似的索引方式）</p><ul><li>索引<ul><li>利用索引的下标值：s[1]</li><li>利用索引名：s[‘a’]</li><li>花式索引：<ul><li>s[[‘b’,‘c’,‘a’]]</li><li>s[[2,1,3]]</li></ul></li><li>布尔索引：<ul><li>s[s&lt;2]</li><li>student[(student[‘Sex’]==‘F’) &amp; (student[‘Age’]&gt;12)]  # 查询所有大于12岁的女生信息</li><li><strong>注</strong>：多条件的布尔索引中，条件之间用<code>&amp;</code>或<code>|</code>连接起来。</li></ul></li><li>布尔索引+花式索引<ul><li>student[(student[‘Sex’]==‘F’) &amp; (student[‘Age’]&gt;12)][[‘Name’,‘Height’,‘Weight’]]  # 查询所有大于12岁女生的姓名、身高和体重</li></ul></li><li>用loc和iloc进行类似numpy数组的’[ , ]'索引或切片（Dataframe部分有详细介绍）</li><li>带有重复标签的轴索引（pandas不强制索引唯一）：此时会根据索引是否重复返回Series或标量值</li></ul></li><li>切片<ul><li>利用索引的下标值：s[0:1]  # 不包含索引值为1的行</li><li>利用索引名：s[‘a’:‘b’]  # 包含索引名’b’的行</li><li>切片部分的值可以修改：s[‘a’,‘b’] = 5</li><li><strong>注</strong>：利用索引名进行分片，边界上行数据也是包含的！！而利用索引下标值进行分片，不包含右边界！！</li></ul></li></ul></li><li><p>获取Series对象的唯一值数组</p><ul><li>方法：Seires.unique()</li><li>返回值：array</li></ul></li><li><p>返回数值数组中最大/小元素对应的索引值</p><ul><li>方法：Series.argmax或Series.argmmin</li><li>返回：最大元素的整数下标值</li></ul></li><li><p>返回数值数组中最大/小元素对应的索引名</p><ul><li>方法：Seires.idxmax或Series.idxmin  # Dataframe有同名方法和详解</li></ul></li><li><p><strong>统计Series中各值出现的频次</strong></p><ul><li>方法：Seires.value_counts()</li><li>返回值：Series。索引部分是可能出现的所有值，数组是各值出现的频次。</li></ul></li><li><p>获取Series中是否出现指定元素的一个bool型数组（之后可用于布尔索引或其他场景）</p><ul><li>方法：Seirse.isin(values)</li><li>参数<ul><li>values（可以是以下之一）<ul><li>数值序列</li><li>集合（元素为数值或字符串都可）</li><li>字符串序列</li></ul></li></ul></li><li>返回值：Seires。判断原Series元素是否出现在values中的一个bool型Series</li></ul></li><li><p><strong>统计一个列标签下各数值出现的频次</strong></p><ul><li>方法：Series.value_counts()</li></ul></li><li><p>快速返回Series数据的统计信息</p><ul><li>方法：Series.describe()  #详见Dataframe中同名方法</li></ul></li><li><p>获取Series中数据在Index中对应的索引 的数组</p><ul><li><p>方法：Index.get_indexer(Series)</p></li><li><p>实例：获取s1中的数据在索引index中对应索引</p><ul><li><p>s1 = pd.Series([‘c’, ‘a’, ‘b’, ‘b’, ‘c’, ‘a’])</p></li><li><p>s2 = pd.Series([‘c’, ‘b’, ‘a’])</p></li><li><p>index = pd.Index(s2)</p></li><li><p>index.get_indexer(s1)</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200729164109333.png" srcset="/img/loading.gif" alt="image-20200729164109333" /></p></li></ul></li><li><p>注：如果Seires的数据在Index中不存在，则返回的索引是-1</p></li></ul></li><li><p>获取表示成员是否出现在特定序列的布尔对象/获取成员资格</p><ul><li><p>方法：Series.isin(values)</p></li><li><p>参数：</p><ul><li>values：set or list-like。表示要测试是否存在的值序列/集合。</li></ul></li><li><p>返回值：Series。将源Series中的数据替换为是否存在于values中的布尔值的新Series对象</p></li><li><p>实例</p><ul><li><p>s = Series([‘a’,‘a’,‘b’,‘c’, ‘b’, ‘a’])</p></li><li><p>s.isin([‘b’,‘c’])</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200729154614054.png" srcset="/img/loading.gif" alt="image-20200729154614054" /></p></li></ul></li><li><p>注：</p><ul><li><p>values参数不能是单一值</p></li><li><p>可以使用isin方法获取一个mask，再利用索引出特定的数据。</p><ul><li><p>实例</p><ul><li><p>s = Series([‘a’,‘a’,‘b’,‘c’, ‘b’, ‘a’])</p></li><li><p>mask = s.isin([‘b’, ‘c’])</p></li><li><p>s[mask]</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200729155014892.png" srcset="/img/loading.gif" alt="image-20200729155014892" /></p></li></ul></li></ul></li></ul></li></ul></li><li><p>重建索引，返回重建索引后的对象</p><ul><li>方法：Series.reindex(index=None, **kwargs)</li><li>参数<ul><li>index：array-like。指定的新索引的列表。如果新索引比数据行要长，则这些多余行数据会自动填充NaN</li><li>method：{None, ‘backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’}。表示填充方式。<ul><li>‘ffill’：以前一个值进行填充</li><li>None ：不填充（默认）</li><li>‘backfill’：以后一个值进行填充</li></ul></li><li>省略若干…</li></ul></li></ul></li></ul><h3 id="类似numpyarray和dict的行为"><a class="markdownIt-Anchor" href="#类似numpyarray和dict的行为"></a> 类似numpy.array和dict的行为</h3><ul><li>Seires具有类似numpy.array的行为<ul><li>类似的切片方式</li><li>都具有dtype属性</li><li><strong>Series转numpy.array</strong>：通过Series.to_numpy方法</li></ul></li><li>Series具有类似dict的行为<ul><li>都支持按键索引值和修改值</li><li>都支持通过in运算符判断某个行标签是否在Seireis索引中，如 ‘a’ in series</li><li>都支持通过 .get 方法获取值</li></ul></li></ul><h2 id="dataframe对象"><a class="markdownIt-Anchor" href="#dataframe对象"></a> Dataframe对象</h2><p>Dataframe包含<strong>index（行标签）</strong>、**columns（列标签）**以及数据三部分。</p><h3 id="常用属性-2"><a class="markdownIt-Anchor" href="#常用属性-2"></a> 常用属性</h3><ul><li><strong>values</strong>：返回Dataframe对象的数据（以array形式）</li><li>dtype<strong>s</strong>：返回每列数据的数据类型<ul><li><strong>注</strong>：区别于Series的属性dtype！</li></ul></li><li>T：返回Dataframe对象的转置</li></ul><h3 id="常用操作及对应方法-2"><a class="markdownIt-Anchor" href="#常用操作及对应方法-2"></a> 常用操作及对应方法</h3><ul><li><strong>创建Dataframe</strong><ul><li>实例化方法：pd.Dataframe(data=None, index=None, columns=None)</li><li>参数：<ul><li>data（有多种来源）<ul><li>Series为元素的字典：d = {‘one’: pd.Series([1., 2., 3.], index=[‘a’, ‘b’, ‘c’]), ‘two’: pd.Series([1., 2., 3., 4.], index=[‘a’, ‘b’, ‘c’, ‘d’])}<ul><li><strong>注</strong>：Dataframe可以看成是以列标签为键，Series为值的字典。</li></ul></li><li>list为元素的字典：d={“id”:[111,112,113],“name”:[“li”,“wang”,“hu”],“age”:[20,30,40]}<ul><li><strong>注</strong>：该方法的行索引需要另外使用index参数引入</li></ul></li><li>嵌套字典：d={‘age’: {‘li’: 20, ‘hu’: 40, ‘wang’: 90},‘sex’: {‘li’: ‘male’, ‘hu’: ‘female’, ‘wang’: ‘male’}}<ul><li><strong>注</strong>：列标签为外层字典的键，行标签为内层字典的键。</li></ul></li><li>字典列表：d：[{‘a’: 1, ‘b’: 2}, {‘a’: 5, ‘b’: 10, ‘c’: 20}]<ul><li><strong>注</strong>：<ul><li>列表中每一个元素(字典)都相当于DataFrame的一行数据</li><li>该方法的行索引需要另外使用index参数引入</li></ul></li></ul></li><li>外部文件<ul><li>csv格式（excel支持）<ul><li>导入方法：pd.read_csv</li></ul></li><li>xlsx格式（excel支持）<ul><li>导入方法：pandas.read_excel</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><strong>索引和切片</strong><ul><li>索引或切片列<ul><li><strong>索引单列</strong>（传入单个值，即列名）：s[‘one’]  # 选出名为’one’的列</li><li><strong>索引多列/花式索引</strong>：s[[‘two’,‘one’]]  # 按顺序选出名为’two’和’one’的两列，以Dataframe返回</li></ul></li><li>索引或切片行<ul><li>切片行：s[:2]  # 选出前两行数据，以Dataframe返回</li><li><strong>布尔索引</strong>：<ul><li><strong>过滤行</strong>：s[s[‘two’] &lt; 5]  # 选出名为’two’列数值小于5的所有行</li><li>**过滤行：**s[s.two &lt; 5]  # 选出名为’two’列数值小于5的所有行   # <strong>注</strong>：如果列名合法，可以按照属性的方式选取列</li><li>s[s&lt;5]   # 选出所有小于5的值，其余值置为NaN</li><li>s[s&lt;5]  = 0 # 选出所有小于5的值，并将其置零</li></ul></li></ul></li><li>用loc和iloc进行类似numpy数组的’[ , ]'索引或切片<ul><li><strong>用loc（轴标签）进行选取</strong><ul><li><strong>选取单一行或几行</strong>：data.loc[“Ohio”]</li><li>选取单一值：data.loc[“Utah”,“two”]</li><li>选取某几行数据的某几列（若行/列数有一个为1，则返回Series，否则返回Dataframe）：data.loc[[“Utah”,“New York”], [‘three’,‘four’]]</li></ul></li><li><strong>用loc进行切片</strong><ul><li>data.loc[:‘Utah’, ‘two’]</li><li>data.loc[‘Colorado’:‘Utah’, ‘two’:‘three’]</li></ul></li><li><strong>用iloc（整数索引）进行选取</strong><ul><li><strong>选取单一行或几行</strong>：data.iloc[1]</li><li>选取单一值：data.iloc[3,3]  # 选取4行4列上的元素</li><li>选取某几行数据的某几列（若行/列数有一个为1，则返回Series，否则返回Dataframe）：data.iloc[[2,3], [0, 1]]</li></ul></li><li><strong>用iloc进行切片</strong><ul><li>data.iloc[:2,:2]  # <strong>注</strong>：切片的右边界元素取不到</li><li>data.iloc[:, :3][data.three &gt; 5]  # 先切片，再布尔索引选取特定行</li></ul></li></ul></li><li>用at和iat选取单一值<ul><li>用at（传入行、列标签）选取单一值：<a href="http://data.at" target="_blank" rel="noopener">data.at</a>[‘Ohio’,‘two’]</li><li>用iat（传入行、列元素的整数索引值）选取单一值：data.iat[1,1]</li></ul></li><li>带有重复标签的轴索引（pandas不强制索引唯一）：此时会根据索引是否重复返回Dataframe或Seires</li><li><strong>注</strong>：<ul><li><strong>常见的错误索引方式</strong><ul><li>s[1]  # 传入单值时默认是索引列，必须要传入列名才行</li><li>s[-1]  # pandas不建议自后向前索引（有些情况会报错），这个Python的list不同，而应该使用loc或是iloc进行索引</li></ul></li></ul></li></ul></li><li><strong>排序</strong><ul><li>按轴标签排序<ul><li>方法：df.sort_index(axis=0,level=None,ascending=True,inplace=False,kind=‘quicksort’,na_position=‘last’,sort_remaining=True,by=None)</li><li>参数<ul><li>axis：0（默认，表示沿行标签名排序） or 1（沿列标签名排序）</li><li>ascending：True（默认） or False，表示是否按升序排列</li></ul></li></ul></li><li><strong>按值排序</strong><ul><li>方法：df.sort_values(<strong>by,axis=0</strong>,ascending=True,inplace=False,kind=‘quicksort’,na_position=‘last’)</li><li>参数<ul><li>by：行/列标签名或行/列标签名组成的列表。表示要<strong>按照列表中顺序依次排序</strong>行/列，即按某一行/列排序后，如果有相同值，再按列表中剩余的行/列排序<ul><li>排序行时要设置axis=0</li><li>排序列时要设置axis=1</li></ul></li></ul></li></ul></li></ul></li><li><strong>排名</strong><ul><li>方法：df.rank(axis=0,method=‘average’,numeric_only=None,na_option=‘keep’,ascending=True,pct=False)</li><li>使用方法可见juypter笔记或参考https://zhuanlan.zhihu.com/p/87593543</li></ul></li><li>生成时间型行索引<ul><li>函数：pd.date_range(start=None, end=None, period=None, freq=‘D’,…)</li><li>参数：<ul><li>start：str or datetime-like。起始时间</li><li>end：str or datetime-like。结束时间</li><li>periods ：integer。周期数</li><li>freq：str or DateOffset</li></ul></li></ul></li><li>数据量较大时查看前5行数据<ul><li>方法：df.head()</li></ul></li><li>返回Dataframe对象的详细信息<ul><li>方法：<a href="http://pd.info" target="_blank" rel="noopener">pd.info</a>()</li><li><strong>该函数返回的信息包括</strong>：行索引、列数、每列的信息（元素数、是否含null值、元素数据类型）、内存占用情况</li></ul></li><li>判断布尔型Dataframe对象中各列/行元素是否含有True<ul><li><strong>注</strong>：结合df.isnull()方法<strong>可以得知每列/行元素是否含有缺失值</strong><ul><li>eg1：df.isnull().any(0) # 判断各列是否含缺失值（sum中的0可以省略）</li><li>eg2：df.isnull().any(1) # 判断各行是否含缺失值</li></ul></li></ul></li><li><strong>快速返回Dataframe每列数据的统计信息</strong><ul><li>方法：df.describe()</li><li>返回的统计信息取决于数值类型。<ul><li>对于数值型数据会返回：元素数、数学期望、标准差、最小/大值、分位数。</li><li>对于object数据会返回：数据总数、唯一值集合包含的元素数、出现次数最多的数（top）、出现次数最多数的频度（freq）</li></ul></li></ul></li><li>Dataframe转numpy.ndarray<ul><li>方法：df.to_numpy()</li></ul></li><li>重建索引，返回重建索引后的对象<ul><li>方法：df.reindex(labels=None,     index=None,     columns=None,     axis=None,     method=None,     copy=True,     level=None,     fill_value=nan,     limit=None,     tolerance=None )</li><li>参数<ul><li>labels：array-like。满足参数axis要求的要重建的行/列索引名</li><li>index/columns：array-like。要重建的行/列索引名</li><li>axis：int（0 or 1） or str（‘index’ or ‘columns’）。指定轴，用于表明labels是行索引还是列索引</li><li>method： {None, ‘backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’}。填充缺失值的方法，类似Series.reindex</li></ul></li><li><strong>注</strong>：<ul><li>一般要同时指定labels和axis参数（修改行索引时可省略axis）</li><li>labels/axis参数不与index/columns同时出现</li></ul></li></ul></li><li><strong>返回行/列数据中最大/小元素对应的索引名</strong><ul><li>方法：df.idxmax(axis=0, skipna=True) 或 df.idxmin(axis=0, skipna=True)</li><li>参数<ul><li>skipna：bool（默认True）。是否排除NaN。设为True时，只有整行/列为NaN时，返回才是NaN。设为False是，若行/列出现NaN，则返回NaN。</li></ul></li><li>实例1：返回各列最大元素的下标<ul><li>df = pd.DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.75, -1.3]], index=[‘a’, ‘b’, ‘c’, ‘d’], columns=[‘one’, ‘two’])</li><li><img src="https://gitee.com/llillz/images/raw/master/image-20200727111932050.png" srcset="/img/loading.gif" alt="image-20200727111932050" /></li></ul></li><li>实例2：返回各行最小元素的下标<ul><li>df = pd.DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.75, -1.3]], index=[‘a’, ‘b’, ‘c’, ‘d’], columns=[‘one’, ‘two’])</li><li><img src="https://gitee.com/llillz/images/raw/master/image-20200727112203623.png" srcset="/img/loading.gif" alt="image-20200727112203623" /></li></ul></li></ul></li></ul><h2 id="index对象"><a class="markdownIt-Anchor" href="#index对象"></a> Index对象</h2><h1 id="数据读写"><a class="markdownIt-Anchor" href="#数据读写"></a> 数据读写</h1><p>与读取有关的函数如下所示</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200731093200053.png" srcset="/img/loading.gif" alt="image-20200731093200053" /></p><p>这些函数的功能主要有</p><ul><li>索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。</li><li>类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。</li><li>日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。</li><li>迭代：支持对大文件进行逐块迭代。</li><li>数据规整：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。</li></ul><h2 id="文本文件"><a class="markdownIt-Anchor" href="#文本文件"></a> 文本文件</h2><ul><li><p>读取csv文件</p><ul><li><p>方法：pd.read_csv(filepath_or_buffer, sep=’,’, delimiter=None, header=‘infer’, names=None, index_col=None,…)</p></li><li><p>参数：</p><ul><li>filepath_or_buffer：str, path object or file-like object。该参数也可以是一个URL（协议支持：http, ftp, s3）</li><li>sep：str, default ‘,’。表示使用的分隔符。如果字符超过1，则被解释为正则字符串。</li><li>delimiter：str，默认为None。表示分隔符的别名。</li><li>header：int, list of int, default ‘infer’。表示选择文件中第几行数据作为列标签，正式数据从该行之后开始计。<ul><li>默认情况<code>header='infer'</code>相当于<code>header=0</code>，即用第一行数据作为列标签。</li><li>当<code>header=None</code>时，会自动生成数字序列作为列标签。</li></ul></li><li>names：array-like, optional。自定义的列标签。</li><li>index_col：int, str, sequence of int / str, or False, default <code>None</code>。表示要作为Dataframe行标签的列。</li><li>skiprows：list-like, int or callable, optional。表示需要忽略的行数（从文件开始计算）</li><li>nrows：int, optional。表示要读取的行数，一般用于在大文件中读取部分数据。</li><li>na_values : scalar, str, list-like, or dict, optional。表示应该被识别为Na/NaN（缺失值）的对象，匹配成功后这些数据会被替换为NaN。当该参数为dict时，每个元素的键表示Dataframe的列，值表示被识别为NaN的数据。<ul><li><strong>注</strong>：默认情况下，以下内容会被认为是NaN: ‘’, ‘#N/A’, ‘#N/A N/A’, ‘#NA’, ‘-1.#IND’, ‘-1.#QNAN’, ‘-NaN’, ‘-nan’,    ‘1.#IND’, ‘1.#QNAN’, ‘’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘n/a’,    ‘nan’, ‘null’</li></ul></li></ul></li><li><p>实例</p><ul><li><p>实例一</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200731142736233.png" srcset="/img/loading.gif" alt="image-20200731142736233" /></p></li><li><p>实例二：指定Dataframe某（几）列数据作为行标签</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200731144916975.png" srcset="/img/loading.gif" alt="image-20200731144916975" /></p></li><li><p>实例三：层次化索引</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200731145624594.png" srcset="/img/loading.gif" alt="image-20200731145624594" /></p></li><li><p>实例四：标记文件中的缺失值</p><ul><li><p>!type ex6.txt</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802135552039.png" srcset="/img/loading.gif" alt="image-20200802135552039" /></p></li><li><p>pd.read_csv(‘ex6.txt’, <em>na_values</em>= [“world”,“foo”])</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802135602850.png" srcset="/img/loading.gif" alt="image-20200802135602850" /></p></li><li><p>df = pd.read_csv(‘ex6.txt’, <em>na_values</em>= {‘something’:[‘one’,‘two’],‘a’:1} )</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802135856704.png" srcset="/img/loading.gif" alt="image-20200802135856704" /></p></li></ul></li><li><p>实例五：读取大文件中的部分行</p><ul><li><p>pd.read_csv(‘ex6.csv’)</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802142212061.png" srcset="/img/loading.gif" alt="image-20200802142212061" /></p></li><li><p>pd.read_csv(‘ex6.csv’, <em>nrows</em>=5)   # 读取5行数据</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802142221872.png" srcset="/img/loading.gif" alt="image-20200802142221872" /></p></li><li><p>实例六：<strong>对大文件进行分块读取后再操作</strong>，具体可见<a href="https://coyli.now.sh/2020/08/02/Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C.html" target="_blank" rel="noopener">这篇文章</a></p></li></ul></li></ul></li></ul></li><li><p>写入csv文件</p><ul><li><p>方法：df.to_csv 或 Series.to_csv（主要介绍前者）</p></li><li><p>参数</p><ul><li>sep：str, 默认是’,’。指定分隔符。</li><li>na_rep：str, 默认是’’。将NaN替换为指定值。</li><li>columns：sequence。表示要写入的列，写入的列的顺序根据序列中元素的顺序。</li><li>header : bool or list of str, 默认为True。表示列标签，可自定义，以替换初始列标签名。</li><li>index : bool, 默认为True。表示行标签。</li></ul></li><li><p>实例：</p><ul><li><p>读取txt文件</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802194943287.png" srcset="/img/loading.gif" alt="image-20200802194943287" /></p></li><li><p>写入csv：df.to_csv(sys.stdout, <em>sep</em>=’|’, <em>header</em>=[6,1], <em>index</em>=False, <em>na_rep</em>=np.NaN, <em>columns</em>=[‘message’, ‘something’])</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802195013676.png" srcset="/img/loading.gif" alt="image-20200802195013676" /></p></li></ul></li></ul></li><li><p>读取表格文件</p><ul><li><p>方法：pd.read_table()</p></li><li><p>参数：该方法和pd.read_csv方法的参数基本类似</p></li><li><p>实例：</p><ul><li><p>实例一：<strong>读取分隔符不规则的表格文件</strong>（本例中，有些分隔符有一个空格以及三个空格两种，这种情况需要设置sep参数为正则表达式）</p><ul><li><p>!type ex4.txt</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802125431075.png" srcset="/img/loading.gif" alt="image-20200802125431075" /></p></li><li><p>pd.read_table(‘ex4.txt’,<em>sep</em>=’\s+’)   # '\s+'表示匹配一个或多个空格</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802125523508.png" srcset="/img/loading.gif" alt="image-20200802125523508" /></p><ul><li><strong>注</strong>：列名比数据行的数量少，所以read_table推断第一列应该是DataFrame的索引</li></ul></li></ul></li></ul></li><li><p>实例二：读取需要跳过某些行的表格文件</p><ul><li><p>!type ex5.txt</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802130309578.png" srcset="/img/loading.gif" alt="image-20200802130309578" /></p></li><li><p>pd.read_table(‘ex5.txt’, <em>sep</em>=’\s+’, <em>skiprows</em>=[1,3,4])</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200802130319573.png" srcset="/img/loading.gif" alt="image-20200802130319573" /></p></li></ul></li></ul></li><li><p>Pandas还支持json、html、xml等格式的读写操作，遇到时再补充。</p></li></ul><h2 id="二进制文件"><a class="markdownIt-Anchor" href="#二进制文件"></a> 二进制文件</h2><ul><li><strong>将Dataframe对象转为二进制文件</strong><ul><li>方法：df.to_pickle(path)</li></ul></li><li><strong>将二进制文件读取为Dataframe对象</strong><ul><li>方法：pd.read_csv(path)</li></ul></li><li><strong>注</strong>：pandas支持的二进制数据格式  # 待补充<ul><li>HDF5</li><li>MessagePack</li></ul></li></ul><h2 id="数据库交互"><a class="markdownIt-Anchor" href="#数据库交互"></a> 数据库交互</h2><p>通过pandas函数从数据库读取数据的一个标准范式</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200805101158032.png" srcset="/img/loading.gif" alt="image-20200805101158032" /></p><h1 id="数据处理"><a class="markdownIt-Anchor" href="#数据处理"></a> 数据处理</h1><h2 id="数据清洗"><a class="markdownIt-Anchor" href="#数据清洗"></a> 数据清洗</h2><h3 id="缺失值空值"><a class="markdownIt-Anchor" href="#缺失值空值"></a> 缺失值/空值</h3><blockquote><p>Q1：如何判断是否存在缺失值？</p><p>A1：isnull方法</p><p>Q2：如何处理缺失值？</p><p>A2：常用的有三大类方法，即删除法、填补法和插值法。</p><ul><li><strong>删除法：</strong><ul><li>当数据中的某个变量大部分值都是缺失值，可以考虑删除改变量；</li><li>当缺失值是随机分布的，且缺失的数量并不是很多是，也可以删除这些缺失的观测；</li></ul></li><li><strong>替补法：</strong><ul><li>对于连续型变量，如果变量的分布近似或就是正态分布的话，可以用<strong>均值</strong>替代那些缺失值；</li><li>如果变量是有偏的，可以使用<strong>中位数</strong>来代替那些缺失值；</li><li>对于离散型变量，我们一般用<strong>众数</strong>去替换那些存在缺失的观测；</li></ul></li><li><strong>插补法：<strong>插补法是基于蒙特卡洛模拟法，结合线性模型、广义线性模型、决策树等方法计算出来的</strong>预测值替换缺失值</strong>。</li></ul></blockquote><p>对于<strong>数值型</strong>数据，pandas使用浮点值<code>NaN</code>（Not a Number）来表示<strong>缺失值</strong>。表示数值型数据时，Python的<code>None</code>也被解释为<code>NaN</code>。</p><p>下面是处理缺失值的一些函数</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200805150631403.png" srcset="/img/loading.gif" alt="image-20200805150631403" /></p><p>判断Dataframe对象的元素是否为null值，返回一个bool型Dateframe对象</p><ul><li>方法：df.isnull()</li><li><strong>注</strong>：结合sum()方法可以<strong>统计各列/行缺失数据的个数</strong><ul><li>eg1：df.isnull().sum(0) # 判断各列缺失数据的个数（sum中的0可以省略）</li><li>eg2：df.isnull().sum(1) # 判断各行缺失数据的个数</li></ul></li></ul><p>删除带有缺失值的行/列</p><ul><li>方法：df.dropna(axis=0,how=‘any’,thresh=None,subset=None,inplace=False)</li><li>参数<ul><li>axis：默认是0（删除行），可以设置为1（删除列）</li><li>how：默认是’any’（行/列中只要包含Null值就删除），可以改为’all’（必须整行/列是Null才删除）</li><li>thresh：non-Null数少于特定阈值thersh的行/列才会被删除（eg. 某列数据包含一个非Null值，设置thresh=1，则该列数据不会被删除）</li><li>subset：行标签或者列标签的列表（eg. [“names”, “age”, “bron”], [2,3,0]）。<ul><li>当为行标签的列表时，表示删除列时要考虑是否存在Null值的行。</li><li>当为列标签的列表时，表示删除行时要考虑是否存在Null值的列。</li></ul></li><li>inplace：True或False（默认）。表示是否立即在本数据上生效。</li></ul></li></ul><p>替补法填充缺失值</p><ul><li>方法：df.fillna(value=None,method=None,axis=None,inplace=False,limit=None,…)</li><li>参数<ul><li>value：scalar, dict, Series, or DataFrame。指定value中的值填充到df对应的行或列中。</li><li>method：‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None。method='ffill’表示以前面的值进行填充</li><li>axis：0 or ‘index’, 1 or ‘columns’。选择按列填充还是按行填充</li><li>inplace：是否立即修改</li><li>limit：限制填充的个数</li><li>实例：<a href="https://www.jb51.net/article/163899.htm" target="_blank" rel="noopener">https://www.jb51.net/article/163899.htm</a></li></ul></li></ul><h3 id="重复值"><a class="markdownIt-Anchor" href="#重复值"></a> 重复值</h3><ul><li><p><strong>判断是否有重复值</strong>：判断Series或Dataframe的行（可以选择特定若干列）是否重复，返回一个bool型的Series。</p><ul><li><p>方法：Seires.duplicated或df.duplicated（主要介绍Dataframe中的使用）</p></li><li><p>参数</p><ul><li>subset：列标签名或是列标签名的列表。表示判断重复行时要考虑的列。默认是所有列。</li><li>keep： {‘first’, ‘last’, False}, default ‘first’。<ul><li>keep='first’时，将除第一次出现的重复值标为True</li><li>keep='last’时，将除最后一次出现的重复值标为True</li><li>keep='first’时，将出现重复的值标为True</li></ul></li></ul></li><li><p>实例</p><ul><li><p>data = pd.DataFrame({‘k1’: [‘one’, ‘two’] * 3 + [‘two’], ‘k2’: [1, 1, 2, 3, 3, 4, 4], ‘k3’:list(range(6))+[5]})</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200805154823649.png" srcset="/img/loading.gif" alt="image-20200805154823649" /></p></li><li><p>data.duplicated(<em>subset</em>=‘k3’, <em>keep</em>=‘last’)</p>  <img src="https://gitee.com/llillz/images/raw/master/image-20200805154902751.png" srcset="/img/loading.gif" alt="image-20200805154902751" style="zoom:70%;" /></li></ul></li></ul></li><li><p><strong>删除具有重复值的行</strong></p><ul><li>方法：Series.drop_duplicates或df.drop_duplicates（主要介绍Dataframe中的使用）</li><li>参数：<ul><li>subset：功能同df.duplicated函数同名参数</li><li>keep：功能同df.duplicated函数同名参数</li><li>inplace：bool。是否立即生效</li><li>ignore_index：bool, default False。如果是True，结果的行标签/索引将重命名为0，1，…，n-1；否则，行标签/索引将保留原来的</li></ul></li></ul></li></ul><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>删除指定行索引/列索引的数据</p><ul><li>方法：df.drop(label=None,axis=0,index=None,columns=None,…)</li><li>参数<ul><li>label：list or list-like。行/列标签名，一般和axis配合使用</li><li>axis：0（默认） or 1。 0表示label是行标签名，1表示label是列标签名</li><li>index：list or list-like。行标签名，单独使用</li><li>columns：list or list-like。列标签名，单独使用</li><li>inplace：True 或 False（默认）。表示是否立即生效</li></ul></li><li>实例<ul><li>实例1：删除满足条件的行<ul><li>student.drop(student[student[‘Age’]&gt;14].index, axis=0)  # 删除大于14岁的所有学生数据</li></ul></li></ul></li></ul><h3 id="替换"><a class="markdownIt-Anchor" href="#替换"></a> 替换</h3><ul><li><p>方法：Series.replace()或df.replace(to_replace=None,<br />value=None,<br />inplace=False,<br />limit=None,<br />regex=False,<br />method=‘pad’,)</p></li><li><p>实例</p><ul><li><pre class="highlight"><code class="python">  s = pd.Series([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])  <span class="hljs-comment"># 定义Seires</span>  df = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],  <span class="hljs-comment"># 定义Dataframe</span>  ...                    <span class="hljs-string">'B'</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],  ...                    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]})    df.replace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 替换单个元素：将0替换成5</span>  df.replace([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>)  <span class="hljs-comment"># 替换元素的列表：将列表中的元素替换成4</span>  s.replace([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], method=<span class="hljs-string">'bfill'</span>)  <span class="hljs-comment"># 控制填充方式：将元素1和2替换成它们距离最近的下一个元素</span>    df.replace({<span class="hljs-string">'A'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'B'</span>: <span class="hljs-number">5</span>}, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 字典形式选中待替换的元素：替换"A"列的元素0和"B"列的元素5为100</span>  df.replace({<span class="hljs-string">'A'</span>: {<span class="hljs-number">0</span>: <span class="hljs-number">100</span>, <span class="hljs-number">4</span>: <span class="hljs-number">400</span>}})  <span class="hljs-comment"># 替换'A'列的元素0为100，替换'A'列的元素4为400</span>  s.replace(<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># 等价于s.replace(to_replace=1, value=None, method='pad')</span>  s.replace({<span class="hljs-number">1</span>:<span class="hljs-literal">None</span>})  <span class="hljs-comment"># 把元素1替换成None</span>  df.replace(regex=[<span class="hljs-string">r'^ba.$'</span>, <span class="hljs-string">'foo'</span>], value=<span class="hljs-string">'new'</span>)  <span class="hljs-comment"># 支持正则表达式，使用很灵活，可见函数的示例</span>  &lt;!--￼<span class="hljs-number">0</span>--&gt;</code></pre></li></ul></li><li><p>实例2：统计各字符串中字符<code>e</code>的个数</p>  <pre><code class="hljs python">s.str.count(<span class="hljs-string">'e'</span>)<span class="hljs-comment">###################</span><span class="hljs-number">0</span>    <span class="hljs-number">1</span><span class="hljs-number">1</span>    <span class="hljs-number">2</span>dtype: int64</code></pre></li></ul><h3 id="时间类型向量化"><a class="markdownIt-Anchor" href="#时间类型向量化"></a> 时间类型向量化</h3><blockquote><p>类似字符串，Pandas 也支持对时间类型的向量化操作。</p><p>时间类型列可用 dt 属性调用相应接口。</p></blockquote><p>返回数据类型为datetime的Series的天数</p><ul><li><p>方法：s.dt.day</p></li><li><p>实例</p>  <pre><code class="hljs python">sr = pd.Series(pd.date_range(<span class="hljs-string">'2020-05-05'</span>, <span class="hljs-string">'2020-05-08'</span>))sr.dt.day<span class="hljs-comment">#######################</span><span class="hljs-number">0</span>    <span class="hljs-number">5</span><span class="hljs-number">1</span>    <span class="hljs-number">6</span><span class="hljs-number">2</span>    <span class="hljs-number">7</span><span class="hljs-number">3</span>    <span class="hljs-number">8</span>dtype: int64</code></pre></li></ul><h2 id="数据转换"><a class="markdownIt-Anchor" href="#数据转换"></a> 数据转换</h2><blockquote><p>replace 一般仅能用于简单的替换操作，所以 pandas 还提供了更为强大的数据转换方法——map、apply、applymap。</p></blockquote><p>Series.map(arg, na_action=None)</p><ul><li><p>功能：对给定序列中的每个值执行相同的映射操作，不同的是 series 中的 map 接口的映射方式既可以是一个函数，也可以是一个字典</p></li><li><p>参数</p><ul><li>arg：一般是函数或字典。对应某一特定映射。</li><li>na_action：{None, ‘ignore’}, default None。当Series中包含NaN值时，na_acrtion='ignore’表示忽略对于NaN值的映射。</li></ul></li><li><p>实例</p><ul><li><p>实例1：字典映射</p>  <pre><code class="hljs python">s = pd.Series([<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, np.nan, <span class="hljs-string">'rabbit'</span>])s.map(&#123;<span class="hljs-string">'cat'</span>:<span class="hljs-string">'chicken'</span>, <span class="hljs-string">'dog'</span>:<span class="hljs-string">'pig'</span>&#125;)  <span class="hljs-comment"># 对于没有指定映射的元素，会默认映射为NaN</span><span class="hljs-comment">###########################</span><span class="hljs-number">0</span>    chicken<span class="hljs-number">1</span>        pig<span class="hljs-number">2</span>        NaN<span class="hljs-number">3</span>        NaNdtype: object</code></pre></li><li><p>实例2：函数映射</p>  <pre><code class="hljs python">s.map(<span class="hljs-string">'I am a &#123;&#125;'</span>.format, na_action=<span class="hljs-string">'ignore'</span>)<span class="hljs-comment">#####################################</span><span class="hljs-number">0</span>       I am a cat<span class="hljs-number">1</span>       I am a dog<span class="hljs-number">2</span>              NaN<span class="hljs-number">3</span>    I am a rabbitdtype: object</code></pre></li></ul></li></ul><p>Series.apply</p><p>df.apply(<strong>func, axis=0</strong>,  raw=False, result_type=None,  args=(), **kwds, )  # Dataframe 列/行级的映射</p><ul><li><p>参数</p><ul><li>func：pandas内置函数或者自定义函数、lambda函数等。表示要应用到行或列上的函数。</li><li>axis：{0 or ‘index’, 1 or ‘columns’}, default 0。要应用到各列（axis=0）还是各行（axis=1）</li></ul></li><li><p>实例</p><ul><li><p><strong>实例1：计算Dataframe各列元素最大值与最小值之差，返回Series</strong></p><ul><li><p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>f = lambda x: x.max() - x.min()</p></li><li><p>frame.apply(func=f)</p><p><img src="https://gitee.com/llillz/images/raw/master/9aabd196-02f1-427e-b44c-ea989a92f429-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li><li><p><strong>实例2：计算Dataframe各行元素最小值和最大值，返回Dataframe</strong></p><ul><li><p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>f = lambda x: pd.Series([x.min(), x.max()], index=[‘min’,‘max’])</p></li><li><p>frame.apply(func=f, axis=1)</p><p><img src="https://gitee.com/llillz/images/raw/master/dc642aa8-3aef-4a93-bbdb-30869f081d8c-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li><li><p>实例3：统计Dataframe各列不同值（各属性值）的频次</p><ul><li><p>data = pd.DataFrame({‘Qu1’: [1, 3, 4, 3, 4], ‘Qu2’: [2, 3, 1, 2, 3], ‘Qu3’: [1, 5, 2, 4, 4]})</p></li><li><p>data.apply(pd.value_counts).fillna(0)</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200729170107335.png" srcset="/img/loading.gif" alt="image-20200729170107335" /></p></li></ul></li></ul></li></ul><p>df.applymap(func)  # Dataframe 元素级映射</p><ul><li><p>实例</p><ul><li><p><strong>获取浮点值的格式化字符串</strong></p><ul><li><p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p></li><li><p>frame.applymap(func=lambda x: ‘%.2f’ % x)</p><p><img src="https://gitee.com/llillz/images/raw/master/550f5e62-8570-4e44-9894-4e4ecf934a53-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p></li></ul></li></ul></li></ul><h2 id="合并与拼接"><a class="markdownIt-Anchor" href="#合并与拼接"></a> <mark>合并与拼接</mark></h2><blockquote><p>Pandas 支持对 Dataframe 进行合并与拼接，这对应与 SQL 的 union 和 join。</p></blockquote><p>主要有以下四个函数实现</p><ul><li>合并<ul><li>merge，完全类似于 SQL 中的 join 语法，仅支持横向合并（把列作为键进行合并），通过设置连接字段，实现对同一记录的不同列信息连接，支持 inner、left、right 和 outer4 种连接方式，但只能实现 SQL 中的等值连接</li><li>join，语法和功能与 merge 一致，不同的是 merge 既可以用 pandas 接口调用，也可以用 dataframe 对象接口调用，而 join 则只适用于 dataframe 对象接口</li></ul></li><li>拼接<ul><li>concat，与 numpy 中的 concatenate 类似，但功能更为强大，可通过一个 axis 参数设置是横向或者拼接，<strong>要求非拼接轴向标签唯一</strong>（例如沿着行进行拼接时，要求每个 df 内部列名是唯一的，但两个 df 间可以重复，毕竟有相同列才有拼接的实际意义）</li><li>append，concat 执行 axis=0 时的一个简化接口，类似列表的 append 函数一样</li></ul></li></ul><h3 id="合并连接"><a class="markdownIt-Anchor" href="#合并连接"></a> 合并/连接</h3><p>合并的基本原理</p><ul><li>指定两个待合并的对象（Dataframe），分别位于左右两边。</li><li>指定左边对象的键，指定右边对象的键。  # 键可以是列名、行索引名</li><li>根据键，采用特定的方式进行合并。  # 这里的特定方式即 SQL 中的四种连接方式</li></ul><p>merge 函数的API</p><pre><code class="hljs python">pd.merge(    left,    right,    how: str = <span class="hljs-string">'inner'</span>,    on=<span class="hljs-literal">None</span>,    left_on=<span class="hljs-literal">None</span>,    right_on=<span class="hljs-literal">None</span>,    left_index: bool = <span class="hljs-literal">False</span>,    right_index: bool = <span class="hljs-literal">False</span>,    sort: bool = <span class="hljs-literal">False</span>,    suffixes=(<span class="hljs-string">'_x'</span>, <span class="hljs-string">'_y'</span>),    copy: bool = <span class="hljs-literal">True</span>,    indicator: bool = <span class="hljs-literal">False</span>,    validate=<span class="hljs-literal">None</span>,) -&gt; 'DataFrame'</code></pre><p>merge 的连接方式有以下四种</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200822165612643.png" srcset="/img/loading.gif" alt="image-20200822165612643" /></p><p>实例</p><ul><li><p>实例1（内连接）：以key为键，合并df1、df2</p><ul><li><pre class="highlight"><code class="python">  df1 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'data1'</span>: range(<span class="hljs-number">7</span>)})  <span class="hljs-comment"># df1中有多个重复的a、b、c</span>    df2 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">3</span>)})  <span class="hljs-comment"># df2中只有唯一的a、b、c（这很重要，如果df2中的键也存在重复的，那么合并的结果将是笛卡尔积，后面会介绍）</span>    <span class="hljs-comment"># 注</span>  <span class="hljs-comment"># 0. df1和df2具有公共的列（key）</span>  <span class="hljs-comment"># 1. df1中的c在df2中不存在 </span>  &lt;!--￼<span class="hljs-number">6</span>--&gt;</code></pre></li><li><p><strong>注</strong>：由于 c 不是公共的键，因此合并后不存在</p></li></ul></li><li><p>实例2（内连接）：在列名不同时，分别指定左右键，然后合并df1、df2</p><ul><li><pre class="highlight"><code class="python">  df3 = pd.DataFrame({<span class="hljs-string">'lkey'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>],<span class="hljs-string">'data1'</span>: range(<span class="hljs-number">7</span>)})  df4 = pd.DataFrame({<span class="hljs-string">'rkey'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">3</span>)})  &lt;!--￼<span class="hljs-number">7</span>--&gt;</code></pre></li></ul></li><li><p>实例3（左连接+笛卡尔积）：合并df1、df2</p><ul><li><pre class="highlight"><code class="python">  df1 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'data1'</span>: range(<span class="hljs-number">6</span>)})  df2 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">5</span>)})  <span class="hljs-comment"># df2 中 key 的值不是唯一的，因此合并时会产生笛卡尔积</span>  &lt;!--￼<span class="hljs-number">8</span>--&gt;</code></pre></li></ul></li><li><p>实例4（根据多个键合并）</p><ul><li><pre class="highlight"><code class="python">  left = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-string">'key2'</span>: [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'one'</span>], <span class="hljs-string">'lval'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]})  right = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-string">'key2'</span>: [<span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>], <span class="hljs-string">'rval'</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]})  &lt;!--￼<span class="hljs-number">9</span>--&gt;</code></pre></li><li><p><strong>注</strong>：根据多个键合并时，可将多个键看成一个整体来理解。</p></li></ul></li><li><p>实例5（指定重复列名的后缀）</p><ul><li><pre class="highlight"><code class="python">  <span class="hljs-comment"># 沿用实例4的left、right</span>  pd.merge(left, right, on=<span class="hljs-string">'key1'</span>, sort=<span class="hljs-string">'key1'</span>)  <span class="hljs-comment"># 不定后缀时</span>  pd.merge(left, right, on=<span class="hljs-string">'key1'</span>, sort=<span class="hljs-string">'key1'</span>, suffixes=[<span class="hljs-string">'_left'</span>, <span class="hljs-string">'_right'</span>])  <span class="hljs-comment"># 通过 suffixes 参数指定后缀</span>  &lt;!--￼<span class="hljs-number">10</span>--&gt;</code></pre></li><li><pre class="highlight"><code class="python">  pd.merge(left1, right1, left_on=<span class="hljs-string">'key'</span>, right_index=<span class="hljs-literal">True</span>)   <span class="hljs-comment"># 左边的键是列名，因此用 left_on 指定</span>  <span class="hljs-comment"># 右边的键是行索引名，因此用 right_index 指定</span>  &lt;!--￼<span class="hljs-number">11</span>--&gt;</code></pre></li></ul></li><li><pre class="highlight"><code class="python">  student.drop(<span class="hljs-string">'Age'</span>, axis=<span class="hljs-number">1</span>).groupby(<span class="hljs-string">'Sex'</span>).max()  &lt;!--￼<span class="hljs-number">12</span>--&gt;</code></pre></li></ul><p>实例3（多分组键+多统计量）：统计各性别中不同年龄学生的最大身高、体重以及最小身高、体重</p><ul><li><pre class="highlight"><code class="python">  <span class="hljs-comment"># student 沿用实例1</span>  student.drop(<span class="hljs-string">'Name'</span>, axis=<span class="hljs-number">1</span>).groupby([<span class="hljs-string">'Sex'</span>, <span class="hljs-string">'Age'</span>]).agg([np.max, np.min])  &lt;!--￼<span class="hljs-number">13</span>--&gt;</code></pre></li><li><p>参数</p><ul><li>columns：一般是列名或者列名组成的列表。表示分组键。</li><li>values：一般是列名或者列名组成的列表。表示要聚合的对象。</li><li>aggfunc：聚合函数，默认是取均值（mean）</li></ul></li><li><p><strong>注</strong>：使用 pivot_table 后返回的是一个Series（堆叠后的Dataframe），如果希望返回Dataframe，需要再使用 unstack 方法。</p></li></ul><h3 id="交叉表"><a class="markdownIt-Anchor" href="#交叉表"></a> 交叉表</h3><h1 id="索引对象"><a class="markdownIt-Anchor" href="#索引对象"></a> 索引对象</h1><h2 id="多索引对象"><a class="markdownIt-Anchor" href="#多索引对象"></a> 多索引对象</h2><h3 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h3><h3 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问</h3><h1 id="数据可视化"><a class="markdownIt-Anchor" href="#数据可视化"></a> 数据可视化</h1>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Pandas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为Fluid主题的Hexo博客添加Utterance评论系统</title>
    <link href="/2020/07/20/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html"/>
    <url>/2020/07/20/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html</url>
    
    <content type="html"><![CDATA[<h1 id="github端"><a class="markdownIt-Anchor" href="#github端"></a> Github端</h1><ol><li><p>创建GitHub仓库用于保存评论（记得设置为公开仓库）</p></li><li><p>通过这个<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">链接</a>为你的仓库添加一个utterances app，在配置页面选择你要用于保存评论的github仓库</p></li><li><p>在utterances<a href="https://utteranc.es/" target="_blank" rel="noopener">官网</a>根据提示获取用于配置的代码（之后这部分代码将嵌入到文章模板页中）</p><ol><li><p>设置仓库名所在的路径（使用第一步创建的仓库）</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200727003959338.png" srcset="/img/loading.gif" alt="image-20200727003959338" /></p></li><li><p>设置每条评论的名称（即issue的名称），这里我选择是把文章的标题作为评论的名称<img src="https://gitee.com/llillz/images/raw/master/image-20200727004415005.png" srcset="/img/loading.gif" alt="image-20200727004415005" /></p></li><li><p>设置issue的标签（可选），这里可以随意<img src="https://gitee.com/llillz/images/raw/master/image-20200727004518633.png" srcset="/img/loading.gif" alt="image-20200727004518633" /></p></li><li><p>当你完成1-3步时，改网页会自动生成配置代码，复制下来，之后要用到<img src="https://gitee.com/llillz/images/raw/master/image-20200727004644133.png" srcset="/img/loading.gif" alt="image-20200727004644133" /></p></li></ol></li></ol><h1 id="hexo端"><a class="markdownIt-Anchor" href="#hexo端"></a> Hexo端</h1><p>我本来想用灵活嵌入的方法（即只需在Fuid配置文件中配置相关项，无需手动嵌入到文章模板页），但是期间遇到一个bug始终无法解决，最后决定采取直接嵌入式的方法。</p><p>接下来我将介绍直接嵌入式的方法（将utterance评论区直接嵌入到文章模板页，这个文章模板页<code>post.ejs</code>在我的电脑位于<code>...\themes\fluid\layout\post.ejs</code>）</p><p>找到评论区部分（Ctrl+F 搜索<code>comments</code>进行定位），先删去Fluid主题有关comments的代码，然后将前面获取到的配置代码拷贝进来，如下图所示</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720211718773.png" srcset="/img/loading.gif" alt="image-20200720211718773" /></p><p>最后，在Fluid配置文件中让comment的配置项<code>enable: true</code>，即可开启评论。</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200727005130208.png" srcset="/img/loading.gif" alt="image-20200727005130208" /></p><p>此时重新生成静态文件然后部署网站即可看到评论。</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720211922988.png" srcset="/img/loading.gif" alt="image-20200720211922988" /></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>Utterances</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为hexo博客的fluid主题添加gitalk评论系统</title>
    <link href="/2020/07/20/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html"/>
    <url>/2020/07/20/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E7%9A%84fluid%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html</url>
    
    <content type="html"><![CDATA[<p>本文将详细介绍（图文）如何在hexo博客的fluid主题下添加gitalk系统。</p><p>gitalk是基于github issue的评论系统，详细的介绍可见<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md" target="_blank" rel="noopener">这里</a>。</p><h1 id="github端的准备"><a class="markdownIt-Anchor" href="#github端的准备"></a> github端的准备</h1><p>主要流程：</p><ol><li>注册GitHub账号</li><li>创建Github仓库，用于保存博客评论</li><li>添加OAuth App，为网站添加第三方（这里是GitHub）登录认证功能</li></ol><p>第1、2步都十分简单，不太清楚的朋友可以自行查阅资料。下面主要详细介绍添加OAuth App的过程：</p><p>首先点击个人头像，进入<code>Settings</code>选项卡</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720011753172.png" srcset="/img/loading.gif" alt="image-20200720011753172" /></p><p>选择<code>OAuth Apps</code>，点击<code>New OAuth App</code></p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720012013813.png" srcset="/img/loading.gif" alt="image-20200720012013813" /></p><p>然后按照下方提示填写内容，新建一个OAuth App</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720012524757.png" srcset="/img/loading.gif" alt="image-20200720012524757" /></p><p>上述都完成后，可以在<code>OAuth Apps</code>选项卡看到你创建好的app</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720012629552.png" srcset="/img/loading.gif" alt="image-20200720012629552" /></p><p>点击进入app后记录下Client ID和Client Secret，这两个字符串在下一部分修改主题的配置文件时会使用到</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720013717628.png" srcset="/img/loading.gif" alt="image-20200720013717628" /></p><h1 id="hexo端的准备"><a class="markdownIt-Anchor" href="#hexo端的准备"></a> hexo端的准备</h1><p>对于fluid主题，只需要修改一下主题的配置文件<code>_config.yml</code>即可。</p><p>修改有关评论的所有项（注释部分介绍了含义）：</p><pre><code class="hljs yml"><span class="hljs-attr">comments:</span>  <span class="hljs-comment"># 评论</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启评论</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">gitalk</span>  <span class="hljs-comment"># 指定使用的评论模块，我们使用的是gitalk系统，所以填gitalk</span><span class="hljs-comment"># Gitalk</span><span class="hljs-comment"># You can get yout ClientID and ClientSecret from https://github.com/settings/applications/new</span><span class="hljs-comment"># More info available at https://github.com/gitalk/gitalk#options</span><span class="hljs-attr">gitalk:</span>  <span class="hljs-attr">clientID:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># GitHub Application Client ID，从OAuth APP中复制过来</span>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># GitHub Application Client Secret,从OAuth APP中复制过来</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">comments</span>  <span class="hljs-comment"># 你保存评论的仓库名（这里是我的仓库，请改成你自己的），请注意，它不是你的仓库完整路径，不包含你的GitHub用户名</span>  <span class="hljs-attr">owner:</span> <span class="hljs-string">'luzhengli'</span>  <span class="hljs-comment"># 你的GitHub用户名，注意外面用单引号包围起来！</span>  <span class="hljs-attr">admin:</span> <span class="hljs-string">['luzhengli']</span>  <span class="hljs-comment"># GitHub repo owner and collaborators, only these guys can initialize github issues, should be like "['admin']" or "['admin1','admin2']" 我这里设置成仅我个人能提交issue（即仅个人能初始化评论区）</span>  <span class="hljs-attr">id:</span> <span class="hljs-string">location.pathname</span>         <span class="hljs-comment"># The unique id of the page. Length must less than 50. 这个不用改</span>  <span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>               <span class="hljs-comment"># Localization language key, en, zh-CN and zh-TW are currently available. 中文网站也不用改</span>  <span class="hljs-attr">labels:</span> <span class="hljs-string">"['Gitalk']"</span>          <span class="hljs-comment"># GitHub issue labels. 一般不用改</span>  <span class="hljs-attr">perPage:</span> <span class="hljs-number">15</span>                   <span class="hljs-comment"># Pagination size, with maximum 100.</span>  <span class="hljs-attr">pagerDirection:</span> <span class="hljs-string">last</span>          <span class="hljs-comment"># Comment sorting direction, available values are last and first. 默认即可</span>  <span class="hljs-attr">distractionFreeMode:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># Facebook-like distraction free mode. 默认即可</span>  <span class="hljs-attr">createIssueManually:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># By default, Gitalk will create a corresponding github issue for your every single page automatically when the logined user is belong to the admin users. You can create it manually by setting this option to true. 默认即可</span></code></pre><p>最后，使用hexo的命令更新静态文件，然后重新部署网站，如果前面都没有问题，那么评论系统就已经搭建完毕了。</p><p>如果在<code>_config.yml</code>配置文件中设置了<code>admin</code>为自己，那么博客中每个文章页都需要你自己手动初始化评论区（对应于GitHub中提交一个issue），在这一点上，gitalk显得十分麻烦。不过不用担心，下一篇文章将介绍如何自动化初始化gitalk评论。</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200720014647865.png" srcset="/img/loading.gif" alt="image-20200720014647865" /></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitalk</tag>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[视频]学会的第一支钢琴曲</title>
    <link href="/2020/05/03/%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%94%AF%E9%92%A2%E7%90%B4%E6%9B%B2.html"/>
    <url>/2020/05/03/%E5%AD%A6%E4%BC%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%94%AF%E9%92%A2%E7%90%B4%E6%9B%B2.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>虽然看起来很简单，但刚上手的时候那真叫个手忙脚乱hh</p><p>ps：噪声感人/(ㄒoㄒ)/~~</p></blockquote><video width=100% height=100% controls><source src="学会的第一支钢琴曲\小星星.mp4"></video>]]></content>
    
    
    <categories>
      
      <category>钢琴</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一次</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言位运算的用途</title>
    <link href="/2020/04/27/C%E8%AF%AD%E8%A8%80%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%9D%E8%80%83.html"/>
    <url>/2020/04/27/C%E8%AF%AD%E8%A8%80%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%9D%E8%80%83.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近复习C语言学到位运算，发现这个特性很灵活，绝不仅仅是简单的与或非语法而已，为加深印象还是决定记录下。位运算的不同运算符结合场景是具有一定含义的，本文分别介绍了按位与或非的基本语法，以及各自的使用场景。</p></blockquote><h1 id="按位与"><a class="markdownIt-Anchor" href="#按位与"></a> 按位与(&amp;)</h1><p>语法简记：有0得0，全1得1</p><p>使用场景：</p><ul><li>“屏蔽”信息位，具体来说包含两层：<ul><li>取特定位：当一个二进制位与0进行“与”时，就可以将其置0，从而屏蔽该信息。</li><li>取特定位：当一个二进制位与1进行“与”时，就可以“取”出该数。</li></ul></li></ul><p>综合两部分，可以用按位与运算符取出一个二进制串的特定位信息，并屏蔽特定位信息。<strong>屏蔽信息位值得单独强调，它有时可以实现掩饰（mask）的效果，比如<code>10011011 &amp; 00000111 = 00000011</code>，这有可能强调之后要操作二进制序列的最后三位（即保留这三位的信息），因此实现通过<code>&amp;</code>将前5位掩饰（mask）起来</strong>。</p><h1 id="或"><a class="markdownIt-Anchor" href="#或"></a> 或(|)</h1><p>语法简记：有1得1，全0得0</p><p>使用场景：</p><ul><li>置位：当一个二进制位与1进行“与”时，就可以将其置1。置位操作和常见，以前写C51时也常用，为I/O提供一个初始电平。</li></ul><h1 id="按位非~"><a class="markdownIt-Anchor" href="#按位非~"></a> 按位非(~)</h1><blockquote><p>这个比较特殊，按位非是一个单目运算，也因此很简单。</p></blockquote><p>语法简记：有1得0，有0得1</p><p>使用场景：</p><ul><li>一时只想到切换单片机的I/O口电气状态了，比如控制流水灯的亮灭等。</li></ul><h1 id="按位异或"><a class="markdownIt-Anchor" href="#按位异或"></a> 按位异或(^)</h1><blockquote><p>这个运算符很强大，以前总觉得异或很奇怪，后来才知道大有用处。</p></blockquote><p>语法简记：相同为1，不同为0</p><p>语法的理解：判断两个位是否为“异”，如果是，则取<code>1</code>，否则取<code>0</code>。即不同为<code>1</code>，相同为<code>0</code>。</p><p><strong>异或运算的性质</strong>：</p><ul><li>异或满足交换律和结合律</li><li>x ^ x == 0</li><li>x ^ 0 == x</li><li>x ^ 1 == ~x</li></ul><p>异或运算的性质带来的更多有趣的应用场景：</p><ul><li><p>所有位置零：与自身异或</p></li><li><p>使特定位翻转（相当于实现了<code>~</code>的功能，但比<code>~</code>更灵活）：与1异或</p></li><li><p>使特定位保留原值：与0异或</p></li><li><p>交换两个值，不用临时变量：</p>  <pre><code class="hljs c">a = a^b;b = a^b;a = a^b;</code></pre><ul><li>优点：不用临时变量</li><li>缺点：速度没有使用临时变量快、当a、b引用的是一个同一个对象时，会使该变量为0。</li></ul></li></ul><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p>[1] 《C语言程序设计（第四版）谭浩强著》</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[视频]抓住人生的高尔夫球</title>
    <link href="/2020/04/20/%E8%A7%86%E9%A2%91-%E6%8A%93%E4%BD%8F%E4%BA%BA%E7%94%9F%E7%9A%84%E9%AB%98%E5%B0%94%E5%A4%AB%E7%90%83.html"/>
    <url>/2020/04/20/%E8%A7%86%E9%A2%91-%E6%8A%93%E4%BD%8F%E4%BA%BA%E7%94%9F%E7%9A%84%E9%AB%98%E5%B0%94%E5%A4%AB%E7%90%83.html</url>
    
    <content type="html"><![CDATA[<p>值得反复观看和思考：</p><video width=100% height=100% controls><source src="视频-抓住人生的高尔夫球\《时间管理》.mp4"></video>]]></content>
    
    
    <categories>
      
      <category>人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>时间管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo新建、编辑并预览文章</title>
    <link href="/2020/04/16/%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0.html"/>
    <url>/2020/04/16/%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0.html</url>
    
    <content type="html"><![CDATA[<p>阅读本文之前，你应当已经搭建并部署好了hexo博客，如果没有我推荐一个实战视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><p>本文将介绍如何在hexo博客中创建、编辑、预览文章，以及如何自定义主题。最后还记录了一些个人部署博客时遇到的坑。</p><h1 id="新建文章"><a class="markdownIt-Anchor" href="#新建文章"></a> 新建文章</h1><h2 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h2><blockquote><p>命令：<code>hexo new [layout] title</code>或 <code>hexo n [layout] title</code></p></blockquote><p>创建文章前要先选定模板，在hexo中也叫做布局。hexo支持三种布局（layout）：post(默认)、draft、page。我们先介绍如何使用已有布局，后面还将会介绍如何自定义布局。</p><p>在博客目录下输入以下命令时，会默认使用post布局，然后自动在<code>source\_posts</code>目录生成一个text1.md文件：</p><pre><code class="hljs bash">$ hexo n text1</code></pre><p>当然你还可以指定布局：</p><pre><code class="hljs bash">$ hexo n [layout_name] draft1</code></pre><p>该命令创建了一个使用特定布局的名为draft1的文章。</p><p>打开之前创建的text1.md文件，我们可以看到文章开头包含以下内容：</p><pre><code class="hljs yml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">text1</span><span class="hljs-attr">author:</span> <span class="hljs-string">luyao</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-10</span> <span class="hljs-number">04</span><span class="hljs-string">:13:36</span><span class="hljs-attr">tags:</span> <span class="hljs-string">hexo</span><span class="hljs-attr">categories:</span> <span class="hljs-string">blog</span><span class="hljs-meta">---</span></code></pre><p>你显示的内容可能未必与我一样，不必担心，这是由于我自定义过。只需要知道，上面的内容在hexo被称作<strong>Front-matter，实际上就是该文章的一些变量，用于实现一些特定的功能</strong>。比如使<code>author: luyao</code>，那么渲染后的文章中将显示文章作者为<code>luyao</code>。</p><p>如何自定义布局呢？实际上，布局是一个markdown文件，它们保存在<code>scaffolds/</code>目录下，可以看到hexo自带的三种布局其实就是三个<code>.md</code>文件：<img src="https://gitee.com/llillz/images/raw/master/image-20200416160635509.png" srcset="/img/loading.gif" alt="image-20200416160635509" /></p><p>而每一个文件中的内容实际只包含一个Front-matter。<img src="https://gitee.com/llillz/images/raw/master/image-20200416160817070.png" srcset="/img/loading.gif" alt="image-20200416160817070" />因此，你可以在这里修改布局或者建立新的布局，然后创建文章时使用这些布局。</p><h2 id="草稿"><a class="markdownIt-Anchor" href="#草稿"></a> 草稿</h2><p>使用<code>hexo n draft draft1</code>命令将在<code>source\</code>目录下创建<code>_drafts</code>目录，并生成一个<code>draft1.md</code>文件。</p><p>当你编辑完草稿后，可以把文章推送到<code>_posts</code>目录下，通过下面的命令：</p><pre><code class="hljs bash">$ hexo publish &lt;file_name&gt;</code></pre><p>可以使用<code>hexo --draft</code>命令可以查看已有草稿。</p><p>想要在本地预览草稿的静态文件，也需要在生成静态文件时加上<code>draft</code>参数。</p><h1 id="编辑文章"><a class="markdownIt-Anchor" href="#编辑文章"></a> 编辑文章</h1><p>以下将介绍一些markdown语法。由于markdown在不同平台的实现略有不用，因此下面的内容只会介绍hexo默认支持的语法（特别基础的常用语法将不再说明，例如<code>#</code>）。此外，由于主题不同，不同机器显示效果也有会一定差异。</p><p>以下是本人操作的环境：</p><ul><li>编辑器：typora</li><li>hexo主题：cactus</li></ul><h2 id="插入图片"><a class="markdownIt-Anchor" href="#插入图片"></a> 插入图片</h2><p>图片几乎是我们写博客时不可或缺的元素。在hexo中插入图片需要先进行一些设置，不过在介绍那之前让我们先回顾一下markdown引用图片的语法：</p><pre><code class="hljs markdown">![<span class="hljs-string">alt</span>](<span class="hljs-link">path [title]</span>)</code></pre><ul><li>path是必选的，表示图片的路径，可使用绝对或相对路径。</li><li>alt是可选的，是图片无法加载时的替代描述文本。</li><li>title是可选的，是图片的标题。</li></ul><p>在hexo中，引用图片不是简单的使用上述语法即可，你还需要为图片制定一个<strong>资源文件夹</strong>。具体来说，hexo中文章引用图片有两种方式：</p><ol><li><p>将所有文章的图片放到<code>source/images</code> 文件夹中（没有就自己创建一个），然后使用markdown语句引用图片。这种方法一般适用于包含少量图片的hexo项目，但是当文章数量增多，图片数也随之增加后，该管理方式就显得有些混乱。因此我个人推荐你使用下面一种方法。</p></li><li><p>为每一个文章创建一个资源文件夹，将图片保存其中，具体步骤如下：</p><ol><li><p>在博客根目录打开<code>_config.yml</code>文件做如下修改：</p> <pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span></code></pre></li><li><p>然后使用<code>hexo n text</code>命令后创建一个使用post布局名为text的文章，你将发现hexo在<code>\source\_post</code>文件夹下创建了一个<code>\text</code>文件夹以及同名的<code>.md</code>文件：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200418002619163.png" srcset="/img/loading.gif" alt="image-20200418002619163" /></p></li><li><p>最后就可以打开<code>text.md</code>文件进行编辑了，你可以把要引用的图片放到同名文件夹下，然后使用相对路径进行引用。<strong>注意</strong>：请不要自作聪明将<code>text.md</code>文件移动到同名文件夹下，经本人尝试，发现这样会导致图片无法正常引用（如果有兴趣可以试试，成功了记得下@博主）。</p></li></ol></li></ol><p><strong>Tip</strong>：如果你使用的是<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>编辑器，可以在编辑器的文件/偏好设置/图像中进行如下设置：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200418003255735.png" srcset="/img/loading.gif" alt="image-20200418003255735" /></p><p>这样你每次直接拷贝到文章的截图将会被自动保存到同名的文件夹下，非常方便~</p><h2 id="插入视频"><a class="markdownIt-Anchor" href="#插入视频"></a> 插入视频</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"480"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"320"</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">video_path</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span></code></pre><ul><li>video_path是视频的存储路径（含双引号），你可以把视频放在文章的同名资源文件夹下，然后用相对路径方式引用。</li><li>width和height是视频区块的宽度和高度，可自定义。</li></ul><h2 id="插入脚注"><a class="markdownIt-Anchor" href="#插入脚注"></a> 插入脚注</h2><img src="使用hexo新建、编辑并预览文章/image-20200820210655333.png" srcset="/img/loading.gif" alt="image-20200820210655333" style="zoom:50%;" /><p>例如（在文章最后可以看到引用对象）：</p><p>这是一句话，后面插入脚注<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是一个脚注">[1]</span></a></sup>。</p><h2 id="引用区块"><a class="markdownIt-Anchor" href="#引用区块"></a> 引用区块</h2><pre><code class="hljs markdown">&#123;% blockquote [author[, source]] [link] [source<span class="hljs-emphasis">_link_</span>title] %&#125;content...&#123;% endblockquote %&#125;</code></pre><p>例如：</p><pre><code class="hljs markdown">&#123;% blockquote luzhengli hello-world https://luzhengli.github.io/2020/04/10/hello-world/ %&#125;Quick Start&#123;% endblockquote %&#125;</code></pre><p>效果如下：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200416171525436.png" srcset="/img/loading.gif" alt="image-20200416171525436" /></p><p>还有一种简单的引用语法：</p><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 这也是引用</span>&gt;<span class="hljs-quote">&gt; 引用1</span>&gt;<span class="hljs-quote">&gt; 饮用2</span></code></pre><p>效果如下：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200416171816955.png" srcset="/img/loading.gif" alt="image-20200416171816955" /></p><h2 id="代码区块"><a class="markdownIt-Anchor" href="#代码区块"></a> 代码区块</h2><pre><code class="hljs markdown">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;code snippet&#123;% endcodeblock %&#125;</code></pre><p>上述形式写起来比较麻烦，我比较喜欢用另外一种语法：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416175337363.png" srcset="/img/loading.gif" alt="image-20200416175337363" /></p><p>例如：</p><p><img src="%E4%BD%BF%E7%94%A8hexo%E6%96%B0%E5%BB%BA%E3%80%81%E7%BC%96%E8%BE%91%E5%B9%B6%E9%A2%84%E8%A7%88%E6%96%87%E7%AB%A0/image-20200416175146292.png" srcset="/img/loading.gif" alt="image-20200416175146292" /></p><p>效果如下：<br /><img src="https://gitee.com/llillz/images/raw/master/image-20200416171403074.png" srcset="/img/loading.gif" alt="image-20200416171403074" /></p><p>hexo还提供了一些<a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">标签插件</a>支持你引用其他资源，如视频、iframe等。不过不常用，有兴趣的朋友可以自己了解下。</p><h1 id="本地预览"><a class="markdownIt-Anchor" href="#本地预览"></a> 本地预览</h1><p>编写好markdown文章后接下来就需要渲染、生成静态文件，启动本地端口查看效果了。</p><h2 id="生成删除静态文件"><a class="markdownIt-Anchor" href="#生成删除静态文件"></a> 生成/删除静态文件</h2><blockquote><p>生成静态文件命令：<code>hexo generate</code>或 <code>hexo g</code></p><p>删除静态文件命令：<code>hexo clean</code></p></blockquote><p>正常情况下，每次启动本地端口前只需更新静态文件即可。Hexo引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。</p><p>如果发生了一些错误，可以先删除静态文件，然后再重新生成。<code>hexo g</code>命令还提供了一个参数<code>-f</code>提供以类似效果。这样做的缺点就是当文章数变多以后渲染时间会更久一些。</p><h2 id="启动本地端口"><a class="markdownIt-Anchor" href="#启动本地端口"></a> 启动本地端口</h2><blockquote><p>命令：<code>hexo server</code>或 <code>hexo s</code></p></blockquote><p>生成静态文件之后，便要启动本地端口。然后访问命令行返回的地址便能在本地访问到博客了。</p><p>效果如下：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200418010323851.png" srcset="/img/loading.gif" alt="image-20200418010323851" /></p><h1 id="自定义主题"><a class="markdownIt-Anchor" href="#自定义主题"></a> 自定义主题</h1><p>启用主题的步骤：</p><ul><li>在GitHub上克隆你喜欢的hexo主题到本地博客的根目录的theme文件夹下：<code>git clone &lt;url&gt; themes/&lt;theme_name&gt;</code></li><li>修改<code>_config.yml</code>文件的theme字段为下载好的主题名，例如：<code>theme: yilia</code></li><li>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</li><li>重新生成静态文件：<code>hexo g</code></li><li>启动本地端口查看效果：<code>hexo s</code></li><li>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</li></ul><p>以上只是主题的启用方法，每个主题还支持许多个性化操作，这些内容需要详见主题的文档。</p><h1 id="再次部署"><a class="markdownIt-Anchor" href="#再次部署"></a> 再次部署</h1><blockquote><p>命令：<code>hexo deploy</code>或 <code>hexo d</code></p></blockquote><p>部署之后等待一会就能通过公网访问到博客了。</p><h1 id="踩过的坑"><a class="markdownIt-Anchor" href="#踩过的坑"></a> 踩过的坑</h1><ol><li><p>部署到github时，仓库名称没有和github账户名一致（这里需要特别小心，账户名≠name）。举例来说，在github个人主页中，小字部分<code>luzhengli</code>才是账户名：</p><p><img src="https://gitee.com/llillz/images/raw/master/image-20200416163415605.png" srcset="/img/loading.gif" alt="image-20200416163415605" /></p></li><li><p>部署后发现无法通过主域名访问，必须主域名+index.html才能访问。解决办法如下：</p><ul><li><p>先查看github主目录是否有index.html</p></li><li><p>删掉.deploy_git文件夹</p></li><li><p>依次输入命令：<code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>。</p></li></ul></li></ol><p>最后的大杀器：当遇到无法解决的问题时，可以直接把blog所在的博客目录删除！重新走一遍流程。</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p>[0] <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a></p><p>[1] <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a></p><p>[2] <a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/writing</a></p><p>[3] <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/front-matter</a></p><p>[4] <a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins</a></p><p>[5] <a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是一个脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
