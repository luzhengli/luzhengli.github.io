<!DOCTYPE html>
<html lang="zh-CN,en,default">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="这是coy的个人博客，分享知识与生活。目前博客还在初创阶段，早期文章可见知乎专栏。">
  <meta name="author" content="luyao">
  <meta name="keywords" content="blog,coy,博客">
  <title>Pandas常用操作参考手册 - coy&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>luyao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-27 00:10">
      2020年7月27日 凌晨
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      89
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：2 天前
                
              </p>
            
            <article class="markdown-body">
              <p>本文从数据操作的导向角度总结了Pandas的一些常见用法，提供场景的同时也提供了部分实例。主要是想给自己做一个参考，以便忘记后查询。</p>
<p>本文将会持续更新。</p>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="series对象包含索引的数组"><a class="markdownIt-Anchor" href="#series对象包含索引的数组"></a> Series对象：包含索引的数组</h2>
<p>Series是由索引和数组两部分构成的</p>
<ul>
<li>索引（这里的索引不仅限于数值型、还支持字符串）
<ul>
<li>Pandas实现：<strong>RangeIndex对象（数值型）、Index（非数值型，如字符串）、DatetimeIndex（时间型）</strong></li>
<li><strong>访问索引</strong>：Series.index</li>
<li><strong>注：索引是有序的</strong></li>
</ul>
</li>
<li>数组
<ul>
<li><strong>访问数组</strong>：Series.values</li>
</ul>
</li>
</ul>
<h3 id="常用属性"><a class="markdownIt-Anchor" href="#常用属性"></a> <strong>常用属性</strong></h3>
<ul>
<li>index：返回Series对象的索引</li>
<li>values：返回Series对象的数组对象</li>
<li>name：返回Series对象的名字
<ul>
<li>可以使用Series.rename方法重命名</li>
</ul>
</li>
</ul>
<h3 id="常用操作及对应方法"><a class="markdownIt-Anchor" href="#常用操作及对应方法"></a> <strong>常用操作及对应方法</strong></h3>
<ul>
<li>
<p>创建Series</p>
<ul>
<li>实例化方法：pd.Series(data=None, index=None)</li>
<li>参数
<ul>
<li>data（有多种格式）
<ul>
<li>ndarray</li>
<li>字典：d={‘b’=1, ‘a’=0, ‘c’=2}
<ul>
<li><strong>注</strong>：Python≥3.6，Pandas≥0.23时，索引将<strong>按dict的插入顺序排序</strong>。</li>
</ul>
</li>
<li>标量值：比如说一个数5
<ul>
<li><strong>注</strong>：此时必须提供索引，否则确定数组部分长度。</li>
</ul>
</li>
</ul>
</li>
<li>index
<ul>
<li>默认创建一个有序列表作为索引[0, 1, …, len(data)-1]，也可以传入字符串列表</li>
<li><strong>注</strong>：
<ul>
<li>如果传入了索引，那么会按照索引的顺序排列数组数据。</li>
<li>索引值可以不唯一！如索引列表可以写成[‘a’,‘b’,‘c’,‘d’,‘d’]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>索引和切片</strong>（Series具备和ndarray类似的索引方式）</p>
<ul>
<li>索引
<ul>
<li>利用索引的下标值：s[1]</li>
<li>利用索引名：s[‘a’]</li>
<li>花式索引：
<ul>
<li>s[[‘b’,‘c’,‘a’]]</li>
<li>s[[2,1,3]]</li>
</ul>
</li>
<li>布尔索引：
<ul>
<li>s[s&lt;2]</li>
<li>student[(student[‘Sex’]==‘F’) &amp; (student[‘Age’]&gt;12)]  # 查询所有大于12岁的女生信息</li>
<li><strong>注</strong>：多条件的布尔索引中，条件之间用<code>&amp;</code>或<code>|</code>连接起来。</li>
</ul>
</li>
<li>布尔索引+花式索引
<ul>
<li>student[(student[‘Sex’]==‘F’) &amp; (student[‘Age’]&gt;12)][[‘Name’,‘Height’,‘Weight’]]  # 查询所有大于12岁女生的姓名、身高和体重</li>
</ul>
</li>
<li>用loc和iloc进行类似numpy数组的’[ , ]'索引或切片（Dataframe部分有详细介绍）</li>
<li>带有重复标签的轴索引（pandas不强制索引唯一）：此时会根据索引是否重复返回Series或标量值</li>
</ul>
</li>
<li>切片
<ul>
<li>利用索引的下标值：s[0:1]  # 不包含索引值为1的行</li>
<li>利用索引名：s[‘a’:‘b’]  # 包含索引名’b’的行</li>
<li>切片部分的值可以修改：s[‘a’,‘b’] = 5</li>
<li><strong>注</strong>：利用索引名进行分片，边界上行数据也是包含的！！而利用索引下标值进行分片，不包含右边界！！</li>
</ul>
</li>
</ul>
</li>
<li>
<p>获取Series对象的唯一值数组</p>
<ul>
<li>方法：Seires.unique()</li>
<li>返回值：array</li>
</ul>
</li>
<li>
<p>返回数值数组中最大/小元素对应的索引值</p>
<ul>
<li>方法：Series.argmax或Series.argmmin</li>
<li>返回：最大元素的整数下标值</li>
</ul>
</li>
<li>
<p>返回数值数组中最大/小元素对应的索引名</p>
<ul>
<li>方法：Seires.idxmax或Series.idxmin  # Dataframe有同名方法和详解</li>
</ul>
</li>
<li>
<p><strong>统计Series中各值出现的频次</strong></p>
<ul>
<li>方法：Seires.value_counts()</li>
<li>返回值：Series。索引部分是可能出现的所有值，数组是各值出现的频次。</li>
</ul>
</li>
<li>
<p>获取Series中是否出现指定元素的一个bool型数组（之后可用于布尔索引或其他场景）</p>
<ul>
<li>方法：Seirse.isin(values)</li>
<li>参数
<ul>
<li>values（可以是以下之一）
<ul>
<li>数值序列</li>
<li>集合（元素为数值或字符串都可）</li>
<li>字符串序列</li>
</ul>
</li>
</ul>
</li>
<li>返回值：Seires。判断原Series元素是否出现在values中的一个bool型Series</li>
</ul>
</li>
<li>
<p><strong>统计一个列标签下各数值出现的频次</strong></p>
<ul>
<li>方法：Series.value_counts()</li>
</ul>
</li>
<li>
<p>快速返回Series数据的统计信息</p>
<ul>
<li>方法：Series.describe()  #详见Dataframe中同名方法</li>
</ul>
</li>
<li>
<p>获取Series中数据在Index中对应的索引 的数组</p>
<ul>
<li>
<p>方法：Index.get_indexer(Series)</p>
</li>
<li>
<p>实例：获取s1中的数据在索引index中对应索引</p>
<ul>
<li>
<p>s1 = pd.Series([‘c’, ‘a’, ‘b’, ‘b’, ‘c’, ‘a’])</p>
</li>
<li>
<p>s2 = pd.Series([‘c’, ‘b’, ‘a’])</p>
</li>
<li>
<p>index = pd.Index(s2)</p>
</li>
<li>
<p>index.get_indexer(s1)</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200729164109333.png" srcset="/img/loading.gif" alt="image-20200729164109333" /></p>
</li>
</ul>
</li>
<li>
<p>注：如果Seires的数据在Index中不存在，则返回的索引是-1</p>
</li>
</ul>
</li>
<li>
<p>获取表示成员是否出现在特定序列的布尔对象/获取成员资格</p>
<ul>
<li>
<p>方法：Series.isin(values)</p>
</li>
<li>
<p>参数：</p>
<ul>
<li>values：set or list-like。表示要测试是否存在的值序列/集合。</li>
</ul>
</li>
<li>
<p>返回值：Series。将源Series中的数据替换为是否存在于values中的布尔值的新Series对象</p>
</li>
<li>
<p>实例</p>
<ul>
<li>
<p>s = Series([‘a’,‘a’,‘b’,‘c’, ‘b’, ‘a’])</p>
</li>
<li>
<p>s.isin([‘b’,‘c’])</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200729154614054.png" srcset="/img/loading.gif" alt="image-20200729154614054" /></p>
</li>
</ul>
</li>
<li>
<p>注：</p>
<ul>
<li>
<p>values参数不能是单一值</p>
</li>
<li>
<p>可以使用isin方法获取一个mask，再利用索引出特定的数据。</p>
<ul>
<li>
<p>实例</p>
<ul>
<li>
<p>s = Series([‘a’,‘a’,‘b’,‘c’, ‘b’, ‘a’])</p>
</li>
<li>
<p>mask = s.isin([‘b’, ‘c’])</p>
</li>
<li>
<p>s[mask]</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200729155014892.png" srcset="/img/loading.gif" alt="image-20200729155014892" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重建索引，返回重建索引后的对象</p>
<ul>
<li>方法：Series.reindex(index=None, **kwargs)</li>
<li>参数
<ul>
<li>index：array-like。指定的新索引的列表。如果新索引比数据行要长，则这些多余行数据会自动填充NaN</li>
<li>method：{None, ‘backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’}。表示填充方式。
<ul>
<li>‘ffill’：以前一个值进行填充</li>
<li>None ：不填充（默认）</li>
<li>‘backfill’：以后一个值进行填充</li>
</ul>
</li>
<li>省略若干…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类似numpyarray和dict的行为"><a class="markdownIt-Anchor" href="#类似numpyarray和dict的行为"></a> 类似numpy.array和dict的行为</h3>
<ul>
<li>Seires具有类似numpy.array的行为
<ul>
<li>类似的切片方式</li>
<li>都具有dtype属性</li>
<li><strong>Series转numpy.array</strong>：通过Series.to_numpy方法</li>
</ul>
</li>
<li>Series具有类似dict的行为
<ul>
<li>都支持按键索引值和修改值</li>
<li>都支持通过in运算符判断某个行标签是否在Seireis索引中，如 ‘a’ in series</li>
<li>都支持通过 .get 方法获取值</li>
</ul>
</li>
</ul>
<h2 id="dataframe对象"><a class="markdownIt-Anchor" href="#dataframe对象"></a> Dataframe对象</h2>
<p>Dataframe包含<strong>index（行标签）</strong>、**columns（列标签）**以及数据三部分。</p>
<h3 id="常用属性-2"><a class="markdownIt-Anchor" href="#常用属性-2"></a> 常用属性</h3>
<ul>
<li><strong>values</strong>：返回Dataframe对象的数据（以array形式）</li>
<li>dtype<strong>s</strong>：返回每列数据的数据类型
<ul>
<li><strong>注</strong>：区别于Series的属性dtype！</li>
</ul>
</li>
<li>T：返回Dataframe对象的转置</li>
</ul>
<h3 id="常用操作及对应方法-2"><a class="markdownIt-Anchor" href="#常用操作及对应方法-2"></a> 常用操作及对应方法</h3>
<ul>
<li><strong>创建Dataframe</strong>
<ul>
<li>实例化方法：pd.Dataframe(data=None, index=None, columns=None)</li>
<li>参数：
<ul>
<li>data（有多种来源）
<ul>
<li>Series为元素的字典：d = {‘one’: pd.Series([1., 2., 3.], index=[‘a’, ‘b’, ‘c’]), ‘two’: pd.Series([1., 2., 3., 4.], index=[‘a’, ‘b’, ‘c’, ‘d’])}
<ul>
<li><strong>注</strong>：Dataframe可以看成是以列标签为键，Series为值的字典。</li>
</ul>
</li>
<li>list为元素的字典：d={“id”:[111,112,113],“name”:[“li”,“wang”,“hu”],“age”:[20,30,40]}
<ul>
<li><strong>注</strong>：该方法的行索引需要另外使用index参数引入</li>
</ul>
</li>
<li>嵌套字典：d={‘age’: {‘li’: 20, ‘hu’: 40, ‘wang’: 90},‘sex’: {‘li’: ‘male’, ‘hu’: ‘female’, ‘wang’: ‘male’}}
<ul>
<li><strong>注</strong>：列标签为外层字典的键，行标签为内层字典的键。</li>
</ul>
</li>
<li>字典列表：d：[{‘a’: 1, ‘b’: 2}, {‘a’: 5, ‘b’: 10, ‘c’: 20}]
<ul>
<li><strong>注</strong>：
<ul>
<li>列表中每一个元素(字典)都相当于DataFrame的一行数据</li>
<li>该方法的行索引需要另外使用index参数引入</li>
</ul>
</li>
</ul>
</li>
<li>外部文件
<ul>
<li>csv格式（excel支持）
<ul>
<li>导入方法：pd.read_csv</li>
</ul>
</li>
<li>xlsx格式（excel支持）
<ul>
<li>导入方法：pandas.read_excel</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>索引和切片</strong>
<ul>
<li>索引或切片列
<ul>
<li><strong>索引单列</strong>（传入单个值，即列名）：s[‘one’]  # 选出名为’one’的列</li>
<li><strong>索引多列/花式索引</strong>：s[[‘two’,‘one’]]  # 按顺序选出名为’two’和’one’的两列，以Dataframe返回</li>
</ul>
</li>
<li>索引或切片行
<ul>
<li>切片行：s[:2]  # 选出前两行数据，以Dataframe返回</li>
<li><strong>布尔索引</strong>：
<ul>
<li><strong>过滤行</strong>：s[s[‘two’] &lt; 5]  # 选出名为’two’列数值小于5的所有行</li>
<li>**过滤行：**s[s.two &lt; 5]  # 选出名为’two’列数值小于5的所有行   # <strong>注</strong>：如果列名合法，可以按照属性的方式选取列</li>
<li>s[s&lt;5]   # 选出所有小于5的值，其余值置为NaN</li>
<li>s[s&lt;5]  = 0 # 选出所有小于5的值，并将其置零</li>
</ul>
</li>
</ul>
</li>
<li>用loc和iloc进行类似numpy数组的’[ , ]'索引或切片
<ul>
<li><strong>用loc（轴标签）进行选取</strong>
<ul>
<li><strong>选取单一行或几行</strong>：data.loc[“Ohio”]</li>
<li>选取单一值：data.loc[“Utah”,“two”]</li>
<li>选取某几行数据的某几列（若行/列数有一个为1，则返回Series，否则返回Dataframe）：data.loc[[“Utah”,“New York”], [‘three’,‘four’]]</li>
</ul>
</li>
<li><strong>用loc进行切片</strong>
<ul>
<li>data.loc[:‘Utah’, ‘two’]</li>
<li>data.loc[‘Colorado’:‘Utah’, ‘two’:‘three’]</li>
</ul>
</li>
<li><strong>用iloc（整数索引）进行选取</strong>
<ul>
<li><strong>选取单一行或几行</strong>：data.iloc[1]</li>
<li>选取单一值：data.iloc[3,3]  # 选取4行4列上的元素</li>
<li>选取某几行数据的某几列（若行/列数有一个为1，则返回Series，否则返回Dataframe）：data.iloc[[2,3], [0, 1]]</li>
</ul>
</li>
<li><strong>用iloc进行切片</strong>
<ul>
<li>data.iloc[:2,:2]  # <strong>注</strong>：切片的右边界元素取不到</li>
<li>data.iloc[:, :3][data.three &gt; 5]  # 先切片，再布尔索引选取特定行</li>
</ul>
</li>
</ul>
</li>
<li>用at和iat选取单一值
<ul>
<li>用at（传入行、列标签）选取单一值：<a href="http://data.at" target="_blank" rel="noopener">data.at</a>[‘Ohio’,‘two’]</li>
<li>用iat（传入行、列元素的整数索引值）选取单一值：data.iat[1,1]</li>
</ul>
</li>
<li>带有重复标签的轴索引（pandas不强制索引唯一）：此时会根据索引是否重复返回Dataframe或Seires</li>
<li><strong>注</strong>：
<ul>
<li><strong>常见的错误索引方式</strong>
<ul>
<li>s[1]  # 传入单值时默认是索引列，必须要传入列名才行</li>
<li>s[-1]  # pandas不建议自后向前索引（有些情况会报错），这个Python的list不同，而应该使用loc或是iloc进行索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>排序</strong>
<ul>
<li>按轴标签排序
<ul>
<li>方法：df.sort_index(axis=0,level=None,ascending=True,inplace=False,kind=‘quicksort’,na_position=‘last’,sort_remaining=True,by=None)</li>
<li>参数
<ul>
<li>axis：0（默认，表示沿行标签名排序） or 1（沿列标签名排序）</li>
<li>ascending：True（默认） or False，表示是否按升序排列</li>
</ul>
</li>
</ul>
</li>
<li><strong>按值排序</strong>
<ul>
<li>方法：df.sort_values(<strong>by,axis=0</strong>,ascending=True,inplace=False,kind=‘quicksort’,na_position=‘last’)</li>
<li>参数
<ul>
<li>by：行/列标签名或行/列标签名组成的列表。表示要<strong>按照列表中顺序依次排序</strong>行/列，即按某一行/列排序后，如果有相同值，再按列表中剩余的行/列排序
<ul>
<li>排序行时要设置axis=0</li>
<li>排序列时要设置axis=1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>排名</strong>
<ul>
<li>方法：df.rank(axis=0,method=‘average’,numeric_only=None,na_option=‘keep’,ascending=True,pct=False)</li>
<li>使用方法可见juypter笔记或参考https://zhuanlan.zhihu.com/p/87593543</li>
</ul>
</li>
<li>生成时间型行索引
<ul>
<li>函数：pd.date_range(start=None, end=None, period=None, freq=‘D’,…)</li>
<li>参数：
<ul>
<li>start：str or datetime-like。起始时间</li>
<li>end：str or datetime-like。结束时间</li>
<li>periods ：integer。周期数</li>
<li>freq：str or DateOffset</li>
</ul>
</li>
</ul>
</li>
<li>数据量较大时查看前5行数据
<ul>
<li>方法：df.head()</li>
</ul>
</li>
<li>返回Dataframe对象的详细信息
<ul>
<li>方法：<a href="http://pd.info" target="_blank" rel="noopener">pd.info</a>()</li>
<li><strong>该函数返回的信息包括</strong>：行索引、列数、每列的信息（元素数、是否含null值、元素数据类型）、内存占用情况</li>
</ul>
</li>
<li>判断布尔型Dataframe对象中各列/行元素是否含有True
<ul>
<li><strong>注</strong>：结合df.isnull()方法<strong>可以得知每列/行元素是否含有缺失值</strong>
<ul>
<li>eg1：df.isnull().any(0) # 判断各列是否含缺失值（sum中的0可以省略）</li>
<li>eg2：df.isnull().any(1) # 判断各行是否含缺失值</li>
</ul>
</li>
</ul>
</li>
<li><strong>快速返回Dataframe每列数据的统计信息</strong>
<ul>
<li>方法：df.describe()</li>
<li>返回的统计信息取决于数值类型。
<ul>
<li>对于数值型数据会返回：元素数、数学期望、标准差、最小/大值、分位数。</li>
<li>对于object数据会返回：数据总数、唯一值集合包含的元素数、出现次数最多的数（top）、出现次数最多数的频度（freq）</li>
</ul>
</li>
</ul>
</li>
<li>Dataframe转numpy.ndarray
<ul>
<li>方法：df.to_numpy()</li>
</ul>
</li>
<li>重建索引，返回重建索引后的对象
<ul>
<li>方法：df.reindex(labels=None,     index=None,     columns=None,     axis=None,     method=None,     copy=True,     level=None,     fill_value=nan,     limit=None,     tolerance=None )</li>
<li>参数
<ul>
<li>labels：array-like。满足参数axis要求的要重建的行/列索引名</li>
<li>index/columns：array-like。要重建的行/列索引名</li>
<li>axis：int（0 or 1） or str（‘index’ or ‘columns’）。指定轴，用于表明labels是行索引还是列索引</li>
<li>method： {None, ‘backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’}。填充缺失值的方法，类似Series.reindex</li>
</ul>
</li>
<li><strong>注</strong>：
<ul>
<li>一般要同时指定labels和axis参数（修改行索引时可省略axis）</li>
<li>labels/axis参数不与index/columns同时出现</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回行/列数据中最大/小元素对应的索引名</strong>
<ul>
<li>方法：df.idxmax(axis=0, skipna=True) 或 df.idxmin(axis=0, skipna=True)</li>
<li>参数
<ul>
<li>skipna：bool（默认True）。是否排除NaN。设为True时，只有整行/列为NaN时，返回才是NaN。设为False是，若行/列出现NaN，则返回NaN。</li>
</ul>
</li>
<li>实例1：返回各列最大元素的下标
<ul>
<li>df = pd.DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.75, -1.3]], index=[‘a’, ‘b’, ‘c’, ‘d’], columns=[‘one’, ‘two’])</li>
<li><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200727111932050.png" srcset="/img/loading.gif" alt="image-20200727111932050" /></li>
</ul>
</li>
<li>实例2：返回各行最小元素的下标
<ul>
<li>df = pd.DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.75, -1.3]], index=[‘a’, ‘b’, ‘c’, ‘d’], columns=[‘one’, ‘two’])</li>
<li><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200727112203623.png" srcset="/img/loading.gif" alt="image-20200727112203623" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="index对象"><a class="markdownIt-Anchor" href="#index对象"></a> Index对象</h2>
<h1 id="数据读写"><a class="markdownIt-Anchor" href="#数据读写"></a> 数据读写</h1>
<p>与读取有关的函数如下所示</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200731093200053.png" srcset="/img/loading.gif" alt="image-20200731093200053" /></p>
<p>这些函数的功能主要有</p>
<ul>
<li>索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。</li>
<li>类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。</li>
<li>日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。</li>
<li>迭代：支持对大文件进行逐块迭代。</li>
<li>数据规整：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。</li>
</ul>
<h2 id="文本文件"><a class="markdownIt-Anchor" href="#文本文件"></a> 文本文件</h2>
<ul>
<li>
<p>读取csv文件</p>
<ul>
<li>
<p>方法：pd.read_csv(filepath_or_buffer, sep=’,’, delimiter=None, header=‘infer’, names=None, index_col=None,…)</p>
</li>
<li>
<p>参数：</p>
<ul>
<li>filepath_or_buffer：str, path object or file-like object。该参数也可以是一个URL（协议支持：http, ftp, s3）</li>
<li>sep：str, default ‘,’。表示使用的分隔符。如果字符超过1，则被解释为正则字符串。</li>
<li>delimiter：str，默认为None。表示分隔符的别名。</li>
<li>header：int, list of int, default ‘infer’。表示选择文件中第几行数据作为列标签，正式数据从该行之后开始计。
<ul>
<li>默认情况<code>header='infer'</code>相当于<code>header=0</code>，即用第一行数据作为列标签。</li>
<li>当<code>header=None</code>时，会自动生成数字序列作为列标签。</li>
</ul>
</li>
<li>names：array-like, optional。自定义的列标签。</li>
<li>index_col：int, str, sequence of int / str, or False, default <code>None</code>。表示要作为Dataframe行标签的列。</li>
<li>skiprows：list-like, int or callable, optional。表示需要忽略的行数（从文件开始计算）</li>
<li>nrows：int, optional。表示要读取的行数，一般用于在大文件中读取部分数据。</li>
<li>na_values : scalar, str, list-like, or dict, optional。表示应该被识别为Na/NaN（缺失值）的对象，匹配成功后这些数据会被替换为NaN。当该参数为dict时，每个元素的键表示Dataframe的列，值表示被识别为NaN的数据。
<ul>
<li><strong>注</strong>：默认情况下，以下内容会被认为是NaN: ‘’, ‘#N/A’, ‘#N/A N/A’, ‘#NA’, ‘-1.#IND’, ‘-1.#QNAN’, ‘-NaN’, ‘-nan’,    ‘1.#IND’, ‘1.#QNAN’, ‘’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘n/a’,    ‘nan’, ‘null’</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li>
<p>实例一</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200731142736233.png" srcset="/img/loading.gif" alt="image-20200731142736233" /></p>
</li>
<li>
<p>实例二：指定Dataframe某（几）列数据作为行标签</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200731144916975.png" srcset="/img/loading.gif" alt="image-20200731144916975" /></p>
</li>
<li>
<p>实例三：层次化索引</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200731145624594.png" srcset="/img/loading.gif" alt="image-20200731145624594" /></p>
</li>
<li>
<p>实例四：标记文件中的缺失值</p>
<ul>
<li>
<p>!type ex6.txt</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802135552039.png" srcset="/img/loading.gif" alt="image-20200802135552039" /></p>
</li>
<li>
<p>pd.read_csv(‘ex6.txt’, <em>na_values</em>= [“world”,“foo”])</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802135602850.png" srcset="/img/loading.gif" alt="image-20200802135602850" /></p>
</li>
<li>
<p>df = pd.read_csv(‘ex6.txt’, <em>na_values</em>= {‘something’:[‘one’,‘two’],‘a’:1} )</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802135856704.png" srcset="/img/loading.gif" alt="image-20200802135856704" /></p>
</li>
</ul>
</li>
<li>
<p>实例五：读取大文件中的部分行</p>
<ul>
<li>
<p>pd.read_csv(‘ex6.csv’)</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802142212061.png" srcset="/img/loading.gif" alt="image-20200802142212061" /></p>
</li>
<li>
<p>pd.read_csv(‘ex6.csv’, <em>nrows</em>=5)   # 读取5行数据</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802142221872.png" srcset="/img/loading.gif" alt="image-20200802142221872" /></p>
</li>
<li>
<p>实例六：<strong>对大文件进行分块读取后再操作</strong>，具体可见<a href="https://coyli.now.sh/2020/08/02/Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C.html" target="_blank" rel="noopener">这篇文章</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>写入csv文件</p>
<ul>
<li>
<p>方法：df.to_csv 或 Series.to_csv（主要介绍前者）</p>
</li>
<li>
<p>参数</p>
<ul>
<li>sep：str, 默认是’,’。指定分隔符。</li>
<li>na_rep：str, 默认是’’。将NaN替换为指定值。</li>
<li>columns：sequence。表示要写入的列，写入的列的顺序根据序列中元素的顺序。</li>
<li>header : bool or list of str, 默认为True。表示列标签，可自定义，以替换初始列标签名。</li>
<li>index : bool, 默认为True。表示行标签。</li>
</ul>
</li>
<li>
<p>实例：</p>
<ul>
<li>
<p>读取txt文件</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802194943287.png" srcset="/img/loading.gif" alt="image-20200802194943287" /></p>
</li>
<li>
<p>写入csv：df.to_csv(sys.stdout, <em>sep</em>=’|’, <em>header</em>=[6,1], <em>index</em>=False, <em>na_rep</em>=np.NaN, <em>columns</em>=[‘message’, ‘something’])</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802195013676.png" srcset="/img/loading.gif" alt="image-20200802195013676" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>读取表格文件</p>
<ul>
<li>
<p>方法：pd.read_table()</p>
</li>
<li>
<p>参数：该方法和pd.read_csv方法的参数基本类似</p>
</li>
<li>
<p>实例：</p>
<ul>
<li>
<p>实例一：<strong>读取分隔符不规则的表格文件</strong>（本例中，有些分隔符有一个空格以及三个空格两种，这种情况需要设置sep参数为正则表达式）</p>
<ul>
<li>
<p>!type ex4.txt</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802125431075.png" srcset="/img/loading.gif" alt="image-20200802125431075" /></p>
</li>
<li>
<p>pd.read_table(‘ex4.txt’,<em>sep</em>=’\s+’)   # '\s+'表示匹配一个或多个空格</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802125523508.png" srcset="/img/loading.gif" alt="image-20200802125523508" /></p>
<ul>
<li><strong>注</strong>：列名比数据行的数量少，所以read_table推断第一列应该是DataFrame的索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实例二：读取需要跳过某些行的表格文件</p>
<ul>
<li>
<p>!type ex5.txt</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802130309578.png" srcset="/img/loading.gif" alt="image-20200802130309578" /></p>
</li>
<li>
<p>pd.read_table(‘ex5.txt’, <em>sep</em>=’\s+’, <em>skiprows</em>=[1,3,4])</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200802130319573.png" srcset="/img/loading.gif" alt="image-20200802130319573" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pandas还支持json、html、xml等格式的读写操作，遇到时再补充。</p>
</li>
</ul>
<h2 id="二进制文件"><a class="markdownIt-Anchor" href="#二进制文件"></a> 二进制文件</h2>
<ul>
<li><strong>将Dataframe对象转为二进制文件</strong>
<ul>
<li>方法：df.to_pickle(path)</li>
</ul>
</li>
<li><strong>将二进制文件读取为Dataframe对象</strong>
<ul>
<li>方法：pd.read_csv(path)</li>
</ul>
</li>
<li><strong>注</strong>：pandas支持的二进制数据格式  # 待补充
<ul>
<li>HDF5</li>
<li>MessagePack</li>
</ul>
</li>
</ul>
<h2 id="数据库交互"><a class="markdownIt-Anchor" href="#数据库交互"></a> 数据库交互</h2>
<p>通过pandas函数从数据库读取数据的一个标准范式</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200805101158032.png" srcset="/img/loading.gif" alt="image-20200805101158032" /></p>
<h1 id="数据处理"><a class="markdownIt-Anchor" href="#数据处理"></a> 数据处理</h1>
<h2 id="数据清洗"><a class="markdownIt-Anchor" href="#数据清洗"></a> 数据清洗</h2>
<h3 id="缺失值空值"><a class="markdownIt-Anchor" href="#缺失值空值"></a> 缺失值/空值</h3>
<blockquote>
<p>Q1：如何判断是否存在缺失值？</p>
<p>A1：isnull方法</p>
<p>Q2：如何处理缺失值？</p>
<p>A2：常用的有三大类方法，即删除法、填补法和插值法。</p>
<ul>
<li><strong>删除法：</strong>
<ul>
<li>当数据中的某个变量大部分值都是缺失值，可以考虑删除改变量；</li>
<li>当缺失值是随机分布的，且缺失的数量并不是很多是，也可以删除这些缺失的观测；</li>
</ul>
</li>
<li><strong>替补法：</strong>
<ul>
<li>对于连续型变量，如果变量的分布近似或就是正态分布的话，可以用<strong>均值</strong>替代那些缺失值；</li>
<li>如果变量是有偏的，可以使用<strong>中位数</strong>来代替那些缺失值；</li>
<li>对于离散型变量，我们一般用<strong>众数</strong>去替换那些存在缺失的观测；</li>
</ul>
</li>
<li><strong>插补法：<strong>插补法是基于蒙特卡洛模拟法，结合线性模型、广义线性模型、决策树等方法计算出来的</strong>预测值替换缺失值</strong>。</li>
</ul>
</blockquote>
<p>对于<strong>数值型</strong>数据，pandas使用浮点值<code>NaN</code>（Not a Number）来表示<strong>缺失值</strong>。表示数值型数据时，Python的<code>None</code>也被解释为<code>NaN</code>。</p>
<p>下面是处理缺失值的一些函数</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200805150631403.png" srcset="/img/loading.gif" alt="image-20200805150631403" /></p>
<p>判断Dataframe对象的元素是否为null值，返回一个bool型Dateframe对象</p>
<ul>
<li>方法：df.isnull()</li>
<li><strong>注</strong>：结合sum()方法可以<strong>统计各列/行缺失数据的个数</strong>
<ul>
<li>eg1：df.isnull().sum(0) # 判断各列缺失数据的个数（sum中的0可以省略）</li>
<li>eg2：df.isnull().sum(1) # 判断各行缺失数据的个数</li>
</ul>
</li>
</ul>
<p>删除带有缺失值的行/列</p>
<ul>
<li>方法：df.dropna(axis=0,how=‘any’,thresh=None,subset=None,inplace=False)</li>
<li>参数
<ul>
<li>axis：默认是0（删除行），可以设置为1（删除列）</li>
<li>how：默认是’any’（行/列中只要包含Null值就删除），可以改为’all’（必须整行/列是Null才删除）</li>
<li>thresh：non-Null数少于特定阈值thersh的行/列才会被删除（eg. 某列数据包含一个非Null值，设置thresh=1，则该列数据不会被删除）</li>
<li>subset：行标签或者列标签的列表（eg. [“names”, “age”, “bron”], [2,3,0]）。
<ul>
<li>当为行标签的列表时，表示删除列时要考虑是否存在Null值的行。</li>
<li>当为列标签的列表时，表示删除行时要考虑是否存在Null值的列。</li>
</ul>
</li>
<li>inplace：True或False（默认）。表示是否立即在本数据上生效。</li>
</ul>
</li>
</ul>
<p>替补法填充缺失值</p>
<ul>
<li>方法：df.fillna(value=None,method=None,axis=None,inplace=False,limit=None,…)</li>
<li>参数
<ul>
<li>value：scalar, dict, Series, or DataFrame。指定value中的值填充到df对应的行或列中。</li>
<li>method：‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None。method='ffill’表示以前面的值进行填充</li>
<li>axis：0 or ‘index’, 1 or ‘columns’。选择按列填充还是按行填充</li>
<li>inplace：是否立即修改</li>
<li>limit：限制填充的个数</li>
<li>实例：<a href="https://www.jb51.net/article/163899.htm" target="_blank" rel="noopener">https://www.jb51.net/article/163899.htm</a></li>
</ul>
</li>
</ul>
<h3 id="重复值"><a class="markdownIt-Anchor" href="#重复值"></a> 重复值</h3>
<ul>
<li>
<p><strong>判断是否有重复值</strong>：判断Series或Dataframe的行（可以选择特定若干列）是否重复，返回一个bool型的Series。</p>
<ul>
<li>
<p>方法：Seires.duplicated或df.duplicated（主要介绍Dataframe中的使用）</p>
</li>
<li>
<p>参数</p>
<ul>
<li>subset：列标签名或是列标签名的列表。表示判断重复行时要考虑的列。默认是所有列。</li>
<li>keep： {‘first’, ‘last’, False}, default ‘first’。
<ul>
<li>keep='first’时，将除第一次出现的重复值标为True</li>
<li>keep='last’时，将除最后一次出现的重复值标为True</li>
<li>keep='first’时，将出现重复的值标为True</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li>
<p>data = pd.DataFrame({‘k1’: [‘one’, ‘two’] * 3 + [‘two’], ‘k2’: [1, 1, 2, 3, 3, 4, 4], ‘k3’:list(range(6))+[5]})</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200805154823649.png" srcset="/img/loading.gif" alt="image-20200805154823649" /></p>
</li>
<li>
<p>data.duplicated(<em>subset</em>=‘k3’, <em>keep</em>=‘last’)</p>
  <img src="Pandas常用操作参考手册/image-20200805154902751.png" srcset="/img/loading.gif" alt="image-20200805154902751" style="zoom:70%;" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>删除具有重复值的行</strong></p>
<ul>
<li>方法：Series.drop_duplicates或df.drop_duplicates（主要介绍Dataframe中的使用）</li>
<li>参数：
<ul>
<li>subset：功能同df.duplicated函数同名参数</li>
<li>keep：功能同df.duplicated函数同名参数</li>
<li>inplace：bool。是否立即生效</li>
<li>ignore_index：bool, default False。如果是True，结果的行标签/索引将重命名为0，1，…，n-1；否则，行标签/索引将保留原来的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<p>删除指定行索引/列索引的数据</p>
<ul>
<li>方法：df.drop(label=None,axis=0,index=None,columns=None,…)</li>
<li>参数
<ul>
<li>label：list or list-like。行/列标签名，一般和axis配合使用</li>
<li>axis：0（默认） or 1。 0表示label是行标签名，1表示label是列标签名</li>
<li>index：list or list-like。行标签名，单独使用</li>
<li>columns：list or list-like。列标签名，单独使用</li>
<li>inplace：True 或 False（默认）。表示是否立即生效</li>
</ul>
</li>
<li>实例
<ul>
<li>实例1：删除满足条件的行
<ul>
<li>student.drop(student[student[‘Age’]&gt;14].index, axis=0)  # 删除大于14岁的所有学生数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="替换"><a class="markdownIt-Anchor" href="#替换"></a> 替换</h3>
<ul>
<li>
<p>方法：Series.replace()或df.replace(to_replace=None,<br />
value=None,<br />
inplace=False,<br />
limit=None,<br />
regex=False,<br />
method=‘pad’,)</p>
</li>
<li>
<p>实例</p>
<ul>
<li>
<pre class="highlight"><code class="python">  s = pd.Series([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])  <span class="hljs-comment"># 定义Seires</span>
  df = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],  <span class="hljs-comment"># 定义Dataframe</span>
  ...                    <span class="hljs-string">'B'</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],
  ...                    <span class="hljs-string">'C'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]})
  
  df.replace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 替换单个元素：将0替换成5</span>
  df.replace([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>)  <span class="hljs-comment"># 替换元素的列表：将列表中的元素替换成4</span>
  s.replace([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], method=<span class="hljs-string">'bfill'</span>)  <span class="hljs-comment"># 控制填充方式：将元素1和2替换成它们距离最近的下一个元素</span>
  
  df.replace({<span class="hljs-string">'A'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'B'</span>: <span class="hljs-number">5</span>}, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 字典形式选中待替换的元素：替换"A"列的元素0和"B"列的元素5为100</span>
  df.replace({<span class="hljs-string">'A'</span>: {<span class="hljs-number">0</span>: <span class="hljs-number">100</span>, <span class="hljs-number">4</span>: <span class="hljs-number">400</span>}})  <span class="hljs-comment"># 替换'A'列的元素0为100，替换'A'列的元素4为400</span>
  s.replace(<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># 等价于s.replace(to_replace=1, value=None, method='pad')</span>
  s.replace({<span class="hljs-number">1</span>:<span class="hljs-literal">None</span>})  <span class="hljs-comment"># 把元素1替换成None</span>
  df.replace(regex=[<span class="hljs-string">r'^ba.$'</span>, <span class="hljs-string">'foo'</span>], value=<span class="hljs-string">'new'</span>)  <span class="hljs-comment"># 支持正则表达式，使用很灵活，可见函数的示例</span>
  &lt;!--￼<span class="hljs-number">0</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>实例2：统计各字符串中字符<code>e</code>的个数</p>
  <pre><code class="hljs python">s.str.count(<span class="hljs-string">'e'</span>)
<span class="hljs-comment">###################</span>
<span class="hljs-number">0</span>    <span class="hljs-number">1</span>
<span class="hljs-number">1</span>    <span class="hljs-number">2</span>
dtype: int64</code></pre>
</li>
</ul>
<h3 id="时间类型向量化"><a class="markdownIt-Anchor" href="#时间类型向量化"></a> 时间类型向量化</h3>
<blockquote>
<p>类似字符串，Pandas 也支持对时间类型的向量化操作。</p>
<p>时间类型列可用 dt 属性调用相应接口。</p>
</blockquote>
<p>返回数据类型为datetime的Series的天数</p>
<ul>
<li>
<p>方法：s.dt.day</p>
</li>
<li>
<p>实例</p>
  <pre><code class="hljs python">sr = pd.Series(pd.date_range(<span class="hljs-string">'2020-05-05'</span>, <span class="hljs-string">'2020-05-08'</span>))
sr.dt.day
<span class="hljs-comment">#######################</span>
<span class="hljs-number">0</span>    <span class="hljs-number">5</span>
<span class="hljs-number">1</span>    <span class="hljs-number">6</span>
<span class="hljs-number">2</span>    <span class="hljs-number">7</span>
<span class="hljs-number">3</span>    <span class="hljs-number">8</span>
dtype: int64</code></pre>
</li>
</ul>
<h2 id="数据转换"><a class="markdownIt-Anchor" href="#数据转换"></a> 数据转换</h2>
<blockquote>
<p>replace 一般仅能用于简单的替换操作，所以 pandas 还提供了更为强大的数据转换方法——map、apply、applymap。</p>
</blockquote>
<p>Series.map(arg, na_action=None)</p>
<ul>
<li>
<p>功能：对给定序列中的每个值执行相同的映射操作，不同的是 series 中的 map 接口的映射方式既可以是一个函数，也可以是一个字典</p>
</li>
<li>
<p>参数</p>
<ul>
<li>arg：一般是函数或字典。对应某一特定映射。</li>
<li>na_action：{None, ‘ignore’}, default None。当Series中包含NaN值时，na_acrtion='ignore’表示忽略对于NaN值的映射。</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li>
<p>实例1：字典映射</p>
  <pre><code class="hljs python">s = pd.Series([<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, np.nan, <span class="hljs-string">'rabbit'</span>])
s.map(&#123;<span class="hljs-string">'cat'</span>:<span class="hljs-string">'chicken'</span>, <span class="hljs-string">'dog'</span>:<span class="hljs-string">'pig'</span>&#125;)  <span class="hljs-comment"># 对于没有指定映射的元素，会默认映射为NaN</span>
<span class="hljs-comment">###########################</span>
<span class="hljs-number">0</span>    chicken
<span class="hljs-number">1</span>        pig
<span class="hljs-number">2</span>        NaN
<span class="hljs-number">3</span>        NaN
dtype: object</code></pre>
</li>
<li>
<p>实例2：函数映射</p>
  <pre><code class="hljs python">s.map(<span class="hljs-string">'I am a &#123;&#125;'</span>.format, na_action=<span class="hljs-string">'ignore'</span>)
<span class="hljs-comment">#####################################</span>
<span class="hljs-number">0</span>       I am a cat
<span class="hljs-number">1</span>       I am a dog
<span class="hljs-number">2</span>              NaN
<span class="hljs-number">3</span>    I am a rabbit
dtype: object</code></pre>
</li>
</ul>
</li>
</ul>
<p>Series.apply</p>
<p>df.apply(<strong>func, axis=0</strong>,  raw=False, result_type=None,  args=(), **kwds, )  # Dataframe 列/行级的映射</p>
<ul>
<li>
<p>参数</p>
<ul>
<li>func：pandas内置函数或者自定义函数、lambda函数等。表示要应用到行或列上的函数。</li>
<li>axis：{0 or ‘index’, 1 or ‘columns’}, default 0。要应用到各列（axis=0）还是各行（axis=1）</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li>
<p><strong>实例1：计算Dataframe各列元素最大值与最小值之差，返回Series</strong></p>
<ul>
<li>
<p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p>
</li>
<li>
<p>f = lambda x: x.max() - x.min()</p>
</li>
<li>
<p>frame.apply(func=f)</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/9aabd196-02f1-427e-b44c-ea989a92f429-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p>
</li>
</ul>
</li>
<li>
<p><strong>实例2：计算Dataframe各行元素最小值和最大值，返回Dataframe</strong></p>
<ul>
<li>
<p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p>
</li>
<li>
<p>f = lambda x: pd.Series([x.min(), x.max()], index=[‘min’,‘max’])</p>
</li>
<li>
<p>frame.apply(func=f, axis=1)</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/dc642aa8-3aef-4a93-bbdb-30869f081d8c-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p>
</li>
</ul>
</li>
<li>
<p>实例3：统计Dataframe各列不同值（各属性值）的频次</p>
<ul>
<li>
<p>data = pd.DataFrame({‘Qu1’: [1, 3, 4, 3, 4], ‘Qu2’: [2, 3, 1, 2, 3], ‘Qu3’: [1, 5, 2, 4, 4]})</p>
</li>
<li>
<p>data.apply(pd.value_counts).fillna(0)</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200729170107335.png" srcset="/img/loading.gif" alt="image-20200729170107335" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>df.applymap(func)  # Dataframe 元素级映射</p>
<ul>
<li>
<p>实例</p>
<ul>
<li>
<p><strong>获取浮点值的格式化字符串</strong></p>
<ul>
<li>
<p>frame = pd.DataFrame(np.random.randn(4, 3), columns=list(‘bde’), index=[‘Utah’, ‘Ohio’, ‘Texas’, ‘Oregon’])</p>
</li>
<li>
<p>frame.applymap(func=lambda x: ‘%.2f’ % x)</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/550f5e62-8570-4e44-9894-4e4ecf934a53-2137757.jpg" srcset="/img/loading.gif" alt="img" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="合并与拼接"><a class="markdownIt-Anchor" href="#合并与拼接"></a> <mark>合并与拼接</mark></h2>
<blockquote>
<p>Pandas 支持对 Dataframe 进行合并与拼接，这对应与 SQL 的 union 和 join。</p>
</blockquote>
<p>主要有以下四个函数实现</p>
<ul>
<li>合并
<ul>
<li>merge，完全类似于 SQL 中的 join 语法，仅支持横向合并（把列作为键进行合并），通过设置连接字段，实现对同一记录的不同列信息连接，支持 inner、left、right 和 outer4 种连接方式，但只能实现 SQL 中的等值连接</li>
<li>join，语法和功能与 merge 一致，不同的是 merge 既可以用 pandas 接口调用，也可以用 dataframe 对象接口调用，而 join 则只适用于 dataframe 对象接口</li>
</ul>
</li>
<li>拼接
<ul>
<li>concat，与 numpy 中的 concatenate 类似，但功能更为强大，可通过一个 axis 参数设置是横向或者拼接，<strong>要求非拼接轴向标签唯一</strong>（例如沿着行进行拼接时，要求每个 df 内部列名是唯一的，但两个 df 间可以重复，毕竟有相同列才有拼接的实际意义）</li>
<li>append，concat 执行 axis=0 时的一个简化接口，类似列表的 append 函数一样</li>
</ul>
</li>
</ul>
<h3 id="合并连接"><a class="markdownIt-Anchor" href="#合并连接"></a> 合并/连接</h3>
<p>合并的基本原理</p>
<ul>
<li>指定两个待合并的对象（Dataframe），分别位于左右两边。</li>
<li>指定左边对象的键，指定右边对象的键。  # 键可以是列名、行索引名</li>
<li>根据键，采用特定的方式进行合并。  # 这里的特定方式即 SQL 中的四种连接方式</li>
</ul>
<p>merge 函数的API</p>
<pre><code class="hljs python">pd.merge(
    left,
    right,
    how: str = <span class="hljs-string">'inner'</span>,
    on=<span class="hljs-literal">None</span>,
    left_on=<span class="hljs-literal">None</span>,
    right_on=<span class="hljs-literal">None</span>,
    left_index: bool = <span class="hljs-literal">False</span>,
    right_index: bool = <span class="hljs-literal">False</span>,
    sort: bool = <span class="hljs-literal">False</span>,
    suffixes=(<span class="hljs-string">'_x'</span>, <span class="hljs-string">'_y'</span>),
    copy: bool = <span class="hljs-literal">True</span>,
    indicator: bool = <span class="hljs-literal">False</span>,
    validate=<span class="hljs-literal">None</span>,
) -&gt; 'DataFrame'</code></pre>
<p>merge 的连接方式有以下四种</p>
<p><img src="Pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/image-20200822165612643.png" srcset="/img/loading.gif" alt="image-20200822165612643" /></p>
<p>实例</p>
<ul>
<li>
<p>实例1（内连接）：以key为键，合并df1、df2</p>
<ul>
<li>
<pre class="highlight"><code class="python">  df1 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'data1'</span>: range(<span class="hljs-number">7</span>)})  <span class="hljs-comment"># df1中有多个重复的a、b、c</span>
  
  df2 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">3</span>)})  <span class="hljs-comment"># df2中只有唯一的a、b、c（这很重要，如果df2中的键也存在重复的，那么合并的结果将是笛卡尔积，后面会介绍）</span>
  
  <span class="hljs-comment"># 注</span>
  <span class="hljs-comment"># 0. df1和df2具有公共的列（key）</span>
  <span class="hljs-comment"># 1. df1中的c在df2中不存在 </span>
  &lt;!--￼<span class="hljs-number">6</span>--&gt;

</code></pre>
</li>
<li>
<p><strong>注</strong>：由于 c 不是公共的键，因此合并后不存在</p>
</li>
</ul>
</li>
<li>
<p>实例2（内连接）：在列名不同时，分别指定左右键，然后合并df1、df2</p>
<ul>
<li>
<pre class="highlight"><code class="python">  df3 = pd.DataFrame({<span class="hljs-string">'lkey'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>],<span class="hljs-string">'data1'</span>: range(<span class="hljs-number">7</span>)})
  df4 = pd.DataFrame({<span class="hljs-string">'rkey'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">3</span>)})
  &lt;!--￼<span class="hljs-number">7</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>实例3（左连接+笛卡尔积）：合并df1、df2</p>
<ul>
<li>
<pre class="highlight"><code class="python">  df1 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'b'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], <span class="hljs-string">'data1'</span>: range(<span class="hljs-number">6</span>)})
  df2 = pd.DataFrame({<span class="hljs-string">'key'</span>: [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], <span class="hljs-string">'data2'</span>: range(<span class="hljs-number">5</span>)})  <span class="hljs-comment"># df2 中 key 的值不是唯一的，因此合并时会产生笛卡尔积</span>
  &lt;!--￼<span class="hljs-number">8</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>实例4（根据多个键合并）</p>
<ul>
<li>
<pre class="highlight"><code class="python">  left = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-string">'key2'</span>: [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>, <span class="hljs-string">'one'</span>], <span class="hljs-string">'lval'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]})
  right = pd.DataFrame({<span class="hljs-string">'key1'</span>: [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'bar'</span>], <span class="hljs-string">'key2'</span>: [<span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>], <span class="hljs-string">'rval'</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]})
  &lt;!--￼<span class="hljs-number">9</span>--&gt;

</code></pre>
</li>
<li>
<p><strong>注</strong>：根据多个键合并时，可将多个键看成一个整体来理解。</p>
</li>
</ul>
</li>
<li>
<p>实例5（指定重复列名的后缀）</p>
<ul>
<li>
<pre class="highlight"><code class="python">  <span class="hljs-comment"># 沿用实例4的left、right</span>
  pd.merge(left, right, on=<span class="hljs-string">'key1'</span>, sort=<span class="hljs-string">'key1'</span>)  <span class="hljs-comment"># 不定后缀时</span>
  pd.merge(left, right, on=<span class="hljs-string">'key1'</span>, sort=<span class="hljs-string">'key1'</span>, suffixes=[<span class="hljs-string">'_left'</span>, <span class="hljs-string">'_right'</span>])  <span class="hljs-comment"># 通过 suffixes 参数指定后缀</span>
  &lt;!--￼<span class="hljs-number">10</span>--&gt;

</code></pre>
</li>
<li>
<pre class="highlight"><code class="python">  pd.merge(left1, right1, left_on=<span class="hljs-string">'key'</span>, right_index=<span class="hljs-literal">True</span>) 
  <span class="hljs-comment"># 左边的键是列名，因此用 left_on 指定</span>
  <span class="hljs-comment"># 右边的键是行索引名，因此用 right_index 指定</span>
  &lt;!--￼<span class="hljs-number">11</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<pre class="highlight"><code class="python">  student.drop(<span class="hljs-string">'Age'</span>, axis=<span class="hljs-number">1</span>).groupby(<span class="hljs-string">'Sex'</span>).max()
  &lt;!--￼<span class="hljs-number">12</span>--&gt;

</code></pre>
</li>
</ul>
<p>实例3（多分组键+多统计量）：统计各性别中不同年龄学生的最大身高、体重以及最小身高、体重</p>
<ul>
<li>
<pre class="highlight"><code class="python">  <span class="hljs-comment"># student 沿用实例1</span>
  student.drop(<span class="hljs-string">'Name'</span>, axis=<span class="hljs-number">1</span>).groupby([<span class="hljs-string">'Sex'</span>, <span class="hljs-string">'Age'</span>]).agg([np.max, np.min])
  &lt;!--￼<span class="hljs-number">13</span>--&gt;

</code></pre>
</li>
<li>
<p>参数</p>
<ul>
<li>columns：一般是列名或者列名组成的列表。表示分组键。</li>
<li>values：一般是列名或者列名组成的列表。表示要聚合的对象。</li>
<li>aggfunc：聚合函数，默认是取均值（mean）</li>
</ul>
</li>
<li>
<p><strong>注</strong>：使用 pivot_table 后返回的是一个Series（堆叠后的Dataframe），如果希望返回Dataframe，需要再使用 unstack 方法。</p>
</li>
</ul>
<h3 id="交叉表"><a class="markdownIt-Anchor" href="#交叉表"></a> 交叉表</h3>
<h1 id="索引对象"><a class="markdownIt-Anchor" href="#索引对象"></a> 索引对象</h1>
<h2 id="多索引对象"><a class="markdownIt-Anchor" href="#多索引对象"></a> 多索引对象</h2>
<h3 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h3>
<h3 id="访问"><a class="markdownIt-Anchor" href="#访问"></a> 访问</h3>
<h1 id="数据可视化"><a class="markdownIt-Anchor" href="#数据可视化"></a> 数据可视化</h1>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Python/">Python</a>
                    
                      <a class="hover-with-bg" href="/categories/Python/Pandas/">Pandas</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Pandas/">Pandas</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/08/02/Pandas%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9A%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Pandas使用技巧：对大文件进行分块操作</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/20/%E4%B8%BAFluid%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Utterance%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html">
                        <span class="hidden-mobile">为Fluid主题的Hexo博客添加Utterance评论系统</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- 《utteranc评论：基于github issue的评论系统 -->
              <div>
                <section id="comments" class="comments">
                  <style>
                    .utterances {
                      max-width: 100%;
                    }
                  </style>
                  <script src="https://utteranc.es/client.js" 
                          repo="luzhengli/commit-utterance" 
                          issue-term="title" 
                          label="utterance"
                          theme="github-light" 
                          crossorigin="anonymous" 
                          async>
                  </script>
                </section>
              </div>
              <!-- utteranc评论》 -->
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>

    <div>  <!-- 统计网站运行时间 -->
      <span id="timeDate">载入天数...</span>
      <span id="times">载入时分秒...</span>
      <script>
        var now = new Date();
        function createtime() {
          var grt = new Date("04/10/2020 00:06:25");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime() + 250);
          days = (now - grt) / 1000 / 60 / 60 / 24;
          dnum = Math.floor(days);
          hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
          hnum = Math.floor(hours);
          if (String(hnum).length == 1) {
            hnum = "0" + hnum;
          }
          minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes);
          if (String(mnum).length == 1) {
            mnum = "0" + mnum;
          }
          seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds);
          if (String(snum).length == 1) {
            snum = "0" + snum;
          }
          document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp" + dnum + "&nbsp天";
          document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
        }
        setInterval("createtime()", 250);
      </script>
    </div>
    
    
  <div class="statistics">
    
    
    
    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Pandas常用操作参考手册&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  













  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?bb1726ecbd2adb17fc76b8413af33852";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
